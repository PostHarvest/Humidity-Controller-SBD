CCS PCH C Compiler, Version 5.015, 5967               12-Mar-18 14:00

               Filename:   E:\BSD\BSD datasheet\SHT75\sht_pic_18f2480_can transfer - Controller\REPORT SHT BME280 TRANSFER\main.lst

               ROM used:   7222 bytes (44%)
                           Largest free fragment is 9158
               RAM used:   64 (8%) at main() level
                           134 (17%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1158
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0096
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
....................  
.................... #include <18F2480.h> 
.................... //////////// Standard Header file for the PIC18F2480 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2480 
*
00A2:  DATA 0D,0A
00A4:  DATA 0D,0A
00A6:  DATA 43,43
00A8:  DATA 53,20
00AA:  DATA 43,41
00AC:  DATA 4E,20
00AE:  DATA 54,52
00B0:  DATA 41,4E
00B2:  DATA 53,46
00B4:  DATA 45,52
00B6:  DATA 20,42
00B8:  DATA 4D,45
00BA:  DATA 32,38
00BC:  DATA 30,20
00BE:  DATA 44,41
00C0:  DATA 54,41
00C2:  DATA 0D,0A
00C4:  DATA 00,00
00C6:  DATA 0D,0A
00C8:  DATA 52,75
00CA:  DATA 6E,6E
00CC:  DATA 69,6E
00CE:  DATA 67,2E
00D0:  DATA 2E,2E
00D2:  DATA 00,00
00D4:  DATA 0D,0A
00D6:  DATA 54,65
00D8:  DATA 6D,70
00DA:  DATA 65,72
00DC:  DATA 61,74
00DE:  DATA 75,72
00E0:  DATA 65,20
00E2:  DATA 53,48
00E4:  DATA 54,37
00E6:  DATA 31,20
00E8:  DATA 3D,20
00EA:  DATA 25,66
00EC:  DATA 33,00
00EE:  DATA 0D,0A
00F0:  DATA 48,75
00F2:  DATA 6D,69
00F4:  DATA 64,69
00F6:  DATA 74,79
00F8:  DATA 20,53
00FA:  DATA 48,54
00FC:  DATA 37,31
00FE:  DATA 20,3D
0100:  DATA 20,25
0102:  DATA 66,33
0104:  DATA 00,00
0106:  DATA 0D,0A
0108:  DATA 6C,6F
010A:  DATA 77,3D
010C:  DATA 25,75
010E:  DATA 00,00
0110:  DATA 0D,0A
0112:  DATA 68,69
0114:  DATA 67,68
0116:  DATA 3D,25
0118:  DATA 75,00
011A:  DATA 0D,0A
011C:  DATA 47,4F
011E:  DATA 54,3A
0120:  DATA 20,42
0122:  DATA 55,46
0124:  DATA 46,3D
0126:  DATA 25,55
0128:  DATA 20,49
012A:  DATA 44,3D
012C:  DATA 25,4C
012E:  DATA 55,20
0130:  DATA 4C,45
0132:  DATA 4E,3D
0134:  DATA 25,55
0136:  DATA 20,4F
0138:  DATA 56,46
013A:  DATA 3D,25
013C:  DATA 55,20
013E:  DATA 00,00
0140:  DATA 46,49
0142:  DATA 4C,54
0144:  DATA 3D,25
0146:  DATA 55,20
0148:  DATA 52,54
014A:  DATA 52,3D
014C:  DATA 25,55
014E:  DATA 20,45
0150:  DATA 58,54
0152:  DATA 3D,25
0154:  DATA 55,20
0156:  DATA 49,4E
0158:  DATA 56,3D
015A:  DATA 25,55
015C:  DATA 00,00
015E:  DATA 0D,0A
0160:  DATA 20,20
0162:  DATA 20,20
0164:  DATA 44,41
0166:  DATA 54,41
0168:  DATA 20,3D
016A:  DATA 20,00
016C:  DATA 0D,0A
016E:  DATA 46,41
0170:  DATA 49,4C
0172:  DATA 20,6F
0174:  DATA 6E,20
0176:  DATA 47,45
0178:  DATA 54,44
017A:  DATA 0D,0A
017C:  DATA 00,00
017E:  DATA 0D,0A
0180:  DATA 50,55
0182:  DATA 54,20
0184:  DATA 25,55
0186:  DATA 3A,20
0188:  DATA 49,44
018A:  DATA 3D,25
018C:  DATA 4C,55
018E:  DATA 20,4C
0190:  DATA 45,4E
0192:  DATA 3D,25
0194:  DATA 55,20
0196:  DATA 00,00
0198:  DATA 50,52
019A:  DATA 49,3D
019C:  DATA 25,55
019E:  DATA 20,45
01A0:  DATA 58,54
01A2:  DATA 3D,25
01A4:  DATA 55,20
01A6:  DATA 52,54
01A8:  DATA 52,3D
01AA:  DATA 25,55
01AC:  DATA 0D,0A
01AE:  DATA 20,20
01B0:  DATA 20,44
01B2:  DATA 41,54
01B4:  DATA 41,20
01B6:  DATA 3D,20
01B8:  DATA 00,00
01BA:  DATA 0D,0A
01BC:  DATA 50,55
01BE:  DATA 54,20
01C0:  DATA 25,55
01C2:  DATA 3A,20
01C4:  DATA 49,44
01C6:  DATA 3D,25
01C8:  DATA 4C,55
01CA:  DATA 20,4C
01CC:  DATA 45,4E
01CE:  DATA 3D,25
01D0:  DATA 55,20
01D2:  DATA 00,00
01D4:  DATA 0D,0A
01D6:  DATA 46,41
01D8:  DATA 49,4C
01DA:  DATA 20,6F
01DC:  DATA 6E,20
01DE:  DATA 50,55
01E0:  DATA 54,44
01E2:  DATA 0D,0A
01E4:  DATA 00,00
01E6:  TBLRD*+
01E8:  MOVF   FF5,F
01EA:  BZ    0206
01EC:  MOVFF  FF6,4E
01F0:  MOVFF  FF7,4F
01F4:  MOVF   FF5,W
01F6:  BTFSS  F9E.4
01F8:  BRA    01F6
01FA:  MOVWF  FAD
01FC:  MOVFF  4E,FF6
0200:  MOVFF  4F,FF7
0204:  BRA    01E6
0206:  RETURN 0
*
069A:  MOVLW  8E
069C:  MOVWF  00
069E:  MOVFF  73,01
06A2:  MOVFF  72,02
06A6:  CLRF   03
06A8:  MOVF   01,F
06AA:  BNZ   06BE
06AC:  MOVFF  02,01
06B0:  CLRF   02
06B2:  MOVLW  08
06B4:  SUBWF  00,F
06B6:  MOVF   01,F
06B8:  BNZ   06BE
06BA:  CLRF   00
06BC:  BRA    06CE
06BE:  BCF    FD8.0
06C0:  BTFSC  01.7
06C2:  BRA    06CC
06C4:  RLCF   02,F
06C6:  RLCF   01,F
06C8:  DECF   00,F
06CA:  BRA    06BE
06CC:  BCF    01.7
06CE:  RETURN 0
*
06F8:  MOVF   x7A,W
06FA:  BTFSC  FD8.2
06FC:  BRA    07E0
06FE:  MOVWF  00
0700:  MOVF   x7E,W
0702:  BTFSC  FD8.2
0704:  BRA    07E0
0706:  ADDWF  00,F
0708:  BNC   0712
070A:  MOVLW  81
070C:  ADDWF  00,F
070E:  BC    07E0
0710:  BRA    071A
0712:  MOVLW  7F
0714:  SUBWF  00,F
0716:  BNC   07E0
0718:  BZ    07E0
071A:  MOVFF  7B,82
071E:  MOVF   x7F,W
0720:  XORWF  x82,F
0722:  BSF    x7B.7
0724:  BSF    x7F.7
0726:  MOVF   x7D,W
0728:  MULWF  x81
072A:  MOVFF  FF4,84
072E:  MOVF   x7C,W
0730:  MULWF  x80
0732:  MOVFF  FF4,03
0736:  MOVFF  FF3,83
073A:  MULWF  x81
073C:  MOVF   FF3,W
073E:  ADDWF  x84,F
0740:  MOVF   FF4,W
0742:  ADDWFC x83,F
0744:  MOVLW  00
0746:  ADDWFC 03,F
0748:  MOVF   x7D,W
074A:  MULWF  x80
074C:  MOVF   FF3,W
074E:  ADDWF  x84,F
0750:  MOVF   FF4,W
0752:  ADDWFC x83,F
0754:  MOVLW  00
0756:  CLRF   02
0758:  ADDWFC 03,F
075A:  ADDWFC 02,F
075C:  MOVF   x7B,W
075E:  MULWF  x81
0760:  MOVF   FF3,W
0762:  ADDWF  x83,F
0764:  MOVF   FF4,W
0766:  ADDWFC 03,F
0768:  MOVLW  00
076A:  ADDWFC 02,F
076C:  MOVF   x7B,W
076E:  MULWF  x80
0770:  MOVF   FF3,W
0772:  ADDWF  03,F
0774:  MOVF   FF4,W
0776:  ADDWFC 02,F
0778:  MOVLW  00
077A:  CLRF   01
077C:  ADDWFC 01,F
077E:  MOVF   x7D,W
0780:  MULWF  x7F
0782:  MOVF   FF3,W
0784:  ADDWF  x83,F
0786:  MOVF   FF4,W
0788:  ADDWFC 03,F
078A:  MOVLW  00
078C:  ADDWFC 02,F
078E:  ADDWFC 01,F
0790:  MOVF   x7C,W
0792:  MULWF  x7F
0794:  MOVF   FF3,W
0796:  ADDWF  03,F
0798:  MOVF   FF4,W
079A:  ADDWFC 02,F
079C:  MOVLW  00
079E:  ADDWFC 01,F
07A0:  MOVF   x7B,W
07A2:  MULWF  x7F
07A4:  MOVF   FF3,W
07A6:  ADDWF  02,F
07A8:  MOVF   FF4,W
07AA:  ADDWFC 01,F
07AC:  INCF   00,F
07AE:  BTFSC  01.7
07B0:  BRA    07BC
07B2:  RLCF   x83,F
07B4:  RLCF   03,F
07B6:  RLCF   02,F
07B8:  RLCF   01,F
07BA:  DECF   00,F
07BC:  MOVLW  00
07BE:  BTFSS  x83.7
07C0:  BRA    07D6
07C2:  INCF   03,F
07C4:  ADDWFC 02,F
07C6:  ADDWFC 01,F
07C8:  MOVF   01,W
07CA:  BNZ   07D6
07CC:  MOVF   02,W
07CE:  BNZ   07D6
07D0:  MOVF   03,W
07D2:  BNZ   07D6
07D4:  INCF   00,F
07D6:  BTFSC  x82.7
07D8:  BSF    01.7
07DA:  BTFSS  x82.7
07DC:  BCF    01.7
07DE:  BRA    07E8
07E0:  CLRF   00
07E2:  CLRF   01
07E4:  CLRF   02
07E6:  CLRF   03
07E8:  RETURN 0
07EA:  MOVLW  80
07EC:  BTFSC  FD8.1
07EE:  XORWF  x7B,F
07F0:  CLRF   x80
07F2:  CLRF   x81
07F4:  MOVFF  77,7F
07F8:  MOVF   x7B,W
07FA:  XORWF  x7F,F
07FC:  MOVF   x76,W
07FE:  BTFSC  FD8.2
0800:  BRA    09BA
0802:  MOVWF  x7E
0804:  MOVWF  00
0806:  MOVF   x7A,W
0808:  BTFSC  FD8.2
080A:  BRA    09CC
080C:  SUBWF  x7E,F
080E:  BTFSC  FD8.2
0810:  BRA    0914
0812:  BNC   088E
0814:  MOVFF  7B,84
0818:  BSF    x84.7
081A:  MOVFF  7C,83
081E:  MOVFF  7D,82
0822:  CLRF   x81
0824:  BCF    FD8.0
0826:  RRCF   x84,F
0828:  RRCF   x83,F
082A:  RRCF   x82,F
082C:  RRCF   x81,F
082E:  DECFSZ x7E,F
0830:  BRA    0822
0832:  BTFSS  x7F.7
0834:  BRA    083C
0836:  BSF    x80.0
0838:  BRA    09F4
083A:  BCF    x80.0
083C:  BCF    x7E.0
083E:  BSF    x80.4
0840:  CLRF   FEA
0842:  MOVLW  79
0844:  MOVWF  FE9
0846:  BRA    0A1A
0848:  BCF    x80.4
084A:  BTFSC  x7F.7
084C:  BRA    0862
084E:  BTFSS  x7E.0
0850:  BRA    0878
0852:  RRCF   x84,F
0854:  RRCF   x83,F
0856:  RRCF   x82,F
0858:  RRCF   x81,F
085A:  INCF   00,F
085C:  BTFSC  FD8.2
085E:  BRA    09EA
0860:  BRA    0878
0862:  BTFSC  x84.7
0864:  BRA    087E
0866:  BCF    FD8.0
0868:  RLCF   x81,F
086A:  RLCF   x82,F
086C:  RLCF   x83,F
086E:  RLCF   x84,F
0870:  DECF   00,F
0872:  BTFSC  FD8.2
0874:  BRA    09EA
0876:  BRA    0862
0878:  BSF    x80.6
087A:  BRA    0952
087C:  BCF    x80.6
087E:  MOVFF  77,7F
0882:  BTFSS  x77.7
0884:  BRA    088A
0886:  BSF    x84.7
0888:  BRA    09DC
088A:  BCF    x84.7
088C:  BRA    09DC
088E:  MOVFF  7A,7E
0892:  MOVFF  7A,00
0896:  MOVF   x76,W
0898:  SUBWF  x7E,F
089A:  MOVFF  77,84
089E:  BSF    x84.7
08A0:  MOVFF  78,83
08A4:  MOVFF  79,82
08A8:  CLRF   x81
08AA:  BCF    FD8.0
08AC:  RRCF   x84,F
08AE:  RRCF   x83,F
08B0:  RRCF   x82,F
08B2:  RRCF   x81,F
08B4:  DECFSZ x7E,F
08B6:  BRA    08A8
08B8:  BTFSS  x7F.7
08BA:  BRA    08C2
08BC:  BSF    x80.1
08BE:  BRA    09F4
08C0:  BCF    x80.1
08C2:  BCF    x7E.0
08C4:  BSF    x80.5
08C6:  CLRF   FEA
08C8:  MOVLW  7D
08CA:  MOVWF  FE9
08CC:  BRA    0A1A
08CE:  BCF    x80.5
08D0:  BTFSC  x7F.7
08D2:  BRA    08E8
08D4:  BTFSS  x7E.0
08D6:  BRA    08FE
08D8:  RRCF   x84,F
08DA:  RRCF   x83,F
08DC:  RRCF   x82,F
08DE:  RRCF   x81,F
08E0:  INCF   00,F
08E2:  BTFSC  FD8.2
08E4:  BRA    09EA
08E6:  BRA    08FE
08E8:  BTFSC  x84.7
08EA:  BRA    0904
08EC:  BCF    FD8.0
08EE:  RLCF   x81,F
08F0:  RLCF   x82,F
08F2:  RLCF   x83,F
08F4:  RLCF   x84,F
08F6:  DECF   00,F
08F8:  BTFSC  FD8.2
08FA:  BRA    09EA
08FC:  BRA    08E8
08FE:  BSF    x80.7
0900:  BRA    0952
0902:  BCF    x80.7
0904:  MOVFF  7B,7F
0908:  BTFSS  x7B.7
090A:  BRA    0910
090C:  BSF    x84.7
090E:  BRA    09DC
0910:  BCF    x84.7
0912:  BRA    09DC
0914:  MOVFF  7B,84
0918:  BSF    x84.7
091A:  MOVFF  7C,83
091E:  MOVFF  7D,82
0922:  BTFSS  x7F.7
0924:  BRA    092E
0926:  BCF    x84.7
0928:  BSF    x80.2
092A:  BRA    09F4
092C:  BCF    x80.2
092E:  CLRF   x81
0930:  BCF    x7E.0
0932:  CLRF   FEA
0934:  MOVLW  79
0936:  MOVWF  FE9
0938:  BRA    0A1A
093A:  BTFSC  x7F.7
093C:  BRA    0976
093E:  MOVFF  77,7F
0942:  BTFSS  x7E.0
0944:  BRA    0952
0946:  RRCF   x84,F
0948:  RRCF   x83,F
094A:  RRCF   x82,F
094C:  RRCF   x81,F
094E:  INCF   00,F
0950:  BZ    09EA
0952:  BTFSS  x81.7
0954:  BRA    096C
0956:  INCF   x82,F
0958:  BNZ   096C
095A:  INCF   x83,F
095C:  BNZ   096C
095E:  INCF   x84,F
0960:  BNZ   096C
0962:  RRCF   x84,F
0964:  RRCF   x83,F
0966:  RRCF   x82,F
0968:  INCF   00,F
096A:  BZ    09EA
096C:  BTFSC  x80.6
096E:  BRA    087C
0970:  BTFSC  x80.7
0972:  BRA    0902
0974:  BRA    09AE
0976:  MOVLW  80
0978:  XORWF  x84,F
097A:  BTFSS  x84.7
097C:  BRA    0986
097E:  BRA    09F4
0980:  MOVFF  7B,7F
0984:  BRA    099A
0986:  MOVFF  77,7F
098A:  MOVF   x84,F
098C:  BNZ   099A
098E:  MOVF   x83,F
0990:  BNZ   099A
0992:  MOVF   x82,F
0994:  BNZ   099A
0996:  CLRF   00
0998:  BRA    09DC
099A:  BTFSC  x84.7
099C:  BRA    09AE
099E:  BCF    FD8.0
09A0:  RLCF   x81,F
09A2:  RLCF   x82,F
09A4:  RLCF   x83,F
09A6:  RLCF   x84,F
09A8:  DECFSZ 00,F
09AA:  BRA    099A
09AC:  BRA    09EA
09AE:  BTFSS  x7F.7
09B0:  BRA    09B6
09B2:  BSF    x84.7
09B4:  BRA    09DC
09B6:  BCF    x84.7
09B8:  BRA    09DC
09BA:  MOVFF  7A,00
09BE:  MOVFF  7B,84
09C2:  MOVFF  7C,83
09C6:  MOVFF  7D,82
09CA:  BRA    09DC
09CC:  MOVFF  76,00
09D0:  MOVFF  77,84
09D4:  MOVFF  78,83
09D8:  MOVFF  79,82
09DC:  MOVFF  84,01
09E0:  MOVFF  83,02
09E4:  MOVFF  82,03
09E8:  BRA    0A52
09EA:  CLRF   00
09EC:  CLRF   01
09EE:  CLRF   02
09F0:  CLRF   03
09F2:  BRA    0A52
09F4:  CLRF   x81
09F6:  COMF   x82,F
09F8:  COMF   x83,F
09FA:  COMF   x84,F
09FC:  COMF   x81,F
09FE:  INCF   x81,F
0A00:  BNZ   0A0C
0A02:  INCF   x82,F
0A04:  BNZ   0A0C
0A06:  INCF   x83,F
0A08:  BNZ   0A0C
0A0A:  INCF   x84,F
0A0C:  BTFSC  x80.0
0A0E:  BRA    083A
0A10:  BTFSC  x80.1
0A12:  BRA    08C0
0A14:  BTFSC  x80.2
0A16:  BRA    092C
0A18:  BRA    0980
0A1A:  MOVF   FEF,W
0A1C:  ADDWF  x82,F
0A1E:  BNC   0A2A
0A20:  INCF   x83,F
0A22:  BNZ   0A2A
0A24:  INCF   x84,F
0A26:  BTFSC  FD8.2
0A28:  BSF    x7E.0
0A2A:  MOVF   FED,F
0A2C:  MOVF   FEF,W
0A2E:  ADDWF  x83,F
0A30:  BNC   0A38
0A32:  INCF   x84,F
0A34:  BTFSC  FD8.2
0A36:  BSF    x7E.0
0A38:  MOVF   FED,F
0A3A:  MOVF   FEF,W
0A3C:  BTFSC  FEF.7
0A3E:  BRA    0A42
0A40:  XORLW  80
0A42:  ADDWF  x84,F
0A44:  BTFSC  FD8.0
0A46:  BSF    x7E.0
0A48:  BTFSC  x80.4
0A4A:  BRA    0848
0A4C:  BTFSC  x80.5
0A4E:  BRA    08CE
0A50:  BRA    093A
0A52:  RETURN 0
0A54:  TBLRD*+
0A56:  MOVFF  FF6,53
0A5A:  MOVFF  FF7,54
0A5E:  MOVF   FF5,W
0A60:  BTFSS  F9E.4
0A62:  BRA    0A60
0A64:  MOVWF  FAD
0A66:  MOVFF  53,FF6
0A6A:  MOVFF  54,FF7
0A6E:  DECFSZ 52,F
0A70:  BRA    0A54
0A72:  RETURN 0
0A74:  MOVF   5B,W
0A76:  SUBLW  B6
0A78:  MOVWF  5B
0A7A:  CLRF   03
0A7C:  MOVFF  5C,5F
0A80:  BSF    5C.7
0A82:  BCF    FD8.0
0A84:  RRCF   5C,F
0A86:  RRCF   5D,F
0A88:  RRCF   5E,F
0A8A:  RRCF   03,F
0A8C:  RRCF   02,F
0A8E:  RRCF   01,F
0A90:  RRCF   00,F
0A92:  DECFSZ 5B,F
0A94:  BRA    0A82
0A96:  BTFSS  5F.7
0A98:  BRA    0AB0
0A9A:  COMF   00,F
0A9C:  COMF   01,F
0A9E:  COMF   02,F
0AA0:  COMF   03,F
0AA2:  INCF   00,F
0AA4:  BTFSC  FD8.2
0AA6:  INCF   01,F
0AA8:  BTFSC  FD8.2
0AAA:  INCF   02,F
0AAC:  BTFSC  FD8.2
0AAE:  INCF   03,F
0AB0:  GOTO   0B90 (RETURN)
0AB4:  BTFSC  FD8.1
0AB6:  BRA    0ABE
0AB8:  CLRF   FEA
0ABA:  MOVLW  64
0ABC:  MOVWF  FE9
0ABE:  CLRF   00
0AC0:  CLRF   01
0AC2:  CLRF   02
0AC4:  CLRF   03
0AC6:  CLRF   x64
0AC8:  CLRF   x65
0ACA:  CLRF   x66
0ACC:  CLRF   x67
0ACE:  MOVF   x63,W
0AD0:  IORWF  x62,W
0AD2:  IORWF  x61,W
0AD4:  IORWF  x60,W
0AD6:  BZ    0B30
0AD8:  MOVLW  20
0ADA:  MOVWF  x68
0ADC:  BCF    FD8.0
0ADE:  RLCF   5C,F
0AE0:  RLCF   5D,F
0AE2:  RLCF   5E,F
0AE4:  RLCF   5F,F
0AE6:  RLCF   x64,F
0AE8:  RLCF   x65,F
0AEA:  RLCF   x66,F
0AEC:  RLCF   x67,F
0AEE:  MOVF   x63,W
0AF0:  SUBWF  x67,W
0AF2:  BNZ   0B04
0AF4:  MOVF   x62,W
0AF6:  SUBWF  x66,W
0AF8:  BNZ   0B04
0AFA:  MOVF   x61,W
0AFC:  SUBWF  x65,W
0AFE:  BNZ   0B04
0B00:  MOVF   x60,W
0B02:  SUBWF  x64,W
0B04:  BNC   0B24
0B06:  MOVF   x60,W
0B08:  SUBWF  x64,F
0B0A:  MOVF   x61,W
0B0C:  BTFSS  FD8.0
0B0E:  INCFSZ x61,W
0B10:  SUBWF  x65,F
0B12:  MOVF   x62,W
0B14:  BTFSS  FD8.0
0B16:  INCFSZ x62,W
0B18:  SUBWF  x66,F
0B1A:  MOVF   x63,W
0B1C:  BTFSS  FD8.0
0B1E:  INCFSZ x63,W
0B20:  SUBWF  x67,F
0B22:  BSF    FD8.0
0B24:  RLCF   00,F
0B26:  RLCF   01,F
0B28:  RLCF   02,F
0B2A:  RLCF   03,F
0B2C:  DECFSZ x68,F
0B2E:  BRA    0ADC
0B30:  MOVFF  64,FEF
0B34:  MOVFF  65,FEC
0B38:  MOVFF  66,FEC
0B3C:  MOVFF  67,FEC
0B40:  RETURN 0
0B42:  MOVF   FE9,W
0B44:  MOVWF  53
0B46:  MOVF   52,W
0B48:  MOVWF  55
0B4A:  BZ    0B7E
0B4C:  MOVFF  51,7D
0B50:  MOVFF  50,7C
0B54:  MOVFF  4F,7B
0B58:  MOVFF  4E,7A
0B5C:  CLRF   x81
0B5E:  CLRF   x80
0B60:  MOVLW  20
0B62:  MOVWF  x7F
0B64:  MOVLW  82
0B66:  MOVWF  x7E
0B68:  RCALL  06F8
0B6A:  MOVFF  03,51
0B6E:  MOVFF  02,50
0B72:  MOVFF  01,4F
0B76:  MOVFF  00,4E
0B7A:  DECFSZ 55,F
0B7C:  BRA    0B4C
0B7E:  MOVFF  51,5E
0B82:  MOVFF  50,5D
0B86:  MOVFF  4F,5C
0B8A:  MOVFF  4E,5B
0B8E:  BRA    0A74
0B90:  MOVFF  03,51
0B94:  MOVFF  02,50
0B98:  MOVFF  01,4F
0B9C:  MOVFF  00,4E
0BA0:  BTFSS  51.7
0BA2:  BRA    0BBE
0BA4:  DECF   53,F
0BA6:  BSF    53.5
0BA8:  COMF   4E,F
0BAA:  COMF   4F,F
0BAC:  COMF   50,F
0BAE:  COMF   51,F
0BB0:  INCF   4E,F
0BB2:  BTFSC  FD8.2
0BB4:  INCF   4F,F
0BB6:  BTFSC  FD8.2
0BB8:  INCF   50,F
0BBA:  BTFSC  FD8.2
0BBC:  INCF   51,F
0BBE:  MOVLW  3B
0BC0:  MOVWF  5A
0BC2:  MOVLW  9A
0BC4:  MOVWF  59
0BC6:  MOVLW  CA
0BC8:  MOVWF  58
0BCA:  CLRF   57
0BCC:  MOVLW  0A
0BCE:  MOVWF  55
0BD0:  MOVF   52,W
0BD2:  BTFSC  FD8.2
0BD4:  INCF   53,F
0BD6:  BSF    FD8.1
0BD8:  CLRF   FEA
0BDA:  MOVLW  4E
0BDC:  MOVWF  FE9
0BDE:  MOVFF  51,5F
0BE2:  MOVFF  50,5E
0BE6:  MOVFF  4F,5D
0BEA:  MOVFF  4E,5C
0BEE:  MOVFF  5A,63
0BF2:  MOVFF  59,62
0BF6:  MOVFF  58,61
0BFA:  MOVFF  57,60
0BFE:  RCALL  0AB4
0C00:  MOVF   01,W
0C02:  MOVF   00,F
0C04:  BNZ   0C24
0C06:  INCF   52,W
0C08:  SUBWF  55,W
0C0A:  BZ    0C24
0C0C:  MOVF   53,W
0C0E:  BZ    0C28
0C10:  ANDLW  0F
0C12:  SUBWF  55,W
0C14:  BZ    0C18
0C16:  BC    0C8E
0C18:  BTFSC  53.7
0C1A:  BRA    0C8E
0C1C:  BTFSC  53.6
0C1E:  BRA    0C28
0C20:  MOVLW  20
0C22:  BRA    0C84
0C24:  MOVLW  20
0C26:  ANDWF  53,F
0C28:  BTFSS  53.5
0C2A:  BRA    0C46
0C2C:  BCF    53.5
0C2E:  MOVF   52,W
0C30:  BTFSS  FD8.2
0C32:  DECF   53,F
0C34:  MOVF   00,W
0C36:  MOVWF  53
0C38:  MOVLW  2D
0C3A:  BTFSS  F9E.4
0C3C:  BRA    0C3A
0C3E:  MOVWF  FAD
0C40:  MOVF   53,W
0C42:  MOVWF  00
0C44:  CLRF   53
0C46:  MOVF   52,W
0C48:  SUBWF  55,W
0C4A:  BNZ   0C62
0C4C:  MOVF   00,W
0C4E:  MOVWF  53
0C50:  MOVLW  2E
0C52:  BTFSS  F9E.4
0C54:  BRA    0C52
0C56:  MOVWF  FAD
0C58:  MOVF   53,W
0C5A:  MOVWF  00
0C5C:  MOVLW  20
0C5E:  ANDWF  53,F
0C60:  MOVLW  00
0C62:  MOVLW  30
0C64:  BTFSS  53.5
0C66:  BRA    0C84
0C68:  BCF    53.5
0C6A:  MOVF   52,W
0C6C:  BTFSS  FD8.2
0C6E:  DECF   53,F
0C70:  MOVF   00,W
0C72:  MOVWF  53
0C74:  MOVLW  2D
0C76:  BTFSS  F9E.4
0C78:  BRA    0C76
0C7A:  MOVWF  FAD
0C7C:  MOVF   53,W
0C7E:  MOVWF  00
0C80:  CLRF   53
0C82:  MOVLW  30
0C84:  ADDWF  00,F
0C86:  MOVF   00,W
0C88:  BTFSS  F9E.4
0C8A:  BRA    0C88
0C8C:  MOVWF  FAD
0C8E:  BCF    FD8.1
0C90:  MOVFF  5A,5F
0C94:  MOVFF  59,5E
0C98:  MOVFF  58,5D
0C9C:  MOVFF  57,5C
0CA0:  CLRF   x63
0CA2:  CLRF   x62
0CA4:  CLRF   x61
0CA6:  MOVLW  0A
0CA8:  MOVWF  x60
0CAA:  RCALL  0AB4
0CAC:  MOVFF  03,5A
0CB0:  MOVFF  02,59
0CB4:  MOVFF  01,58
0CB8:  MOVFF  00,57
0CBC:  DECFSZ 55,F
0CBE:  BRA    0BD6
0CC0:  RETURN 0
0CC2:  MOVF   55,W
0CC4:  CLRF   01
0CC6:  SUBWF  54,W
0CC8:  BC    0CD0
0CCA:  MOVFF  54,00
0CCE:  BRA    0CE8
0CD0:  CLRF   00
0CD2:  MOVLW  08
0CD4:  MOVWF  56
0CD6:  RLCF   54,F
0CD8:  RLCF   00,F
0CDA:  MOVF   55,W
0CDC:  SUBWF  00,W
0CDE:  BTFSC  FD8.0
0CE0:  MOVWF  00
0CE2:  RLCF   01,F
0CE4:  DECFSZ 56,F
0CE6:  BRA    0CD6
0CE8:  RETURN 0
0CEA:  MOVF   01,W
0CEC:  MOVFF  52,54
0CF0:  MOVLW  64
0CF2:  MOVWF  55
0CF4:  RCALL  0CC2
0CF6:  MOVFF  00,52
0CFA:  MOVF   01,W
0CFC:  MOVLW  30
0CFE:  BNZ   0D0E
0D00:  BTFSS  53.1
0D02:  BRA    0D1E
0D04:  BTFSC  53.3
0D06:  BRA    0D1E
0D08:  BTFSC  53.4
0D0A:  MOVLW  20
0D0C:  BRA    0D14
0D0E:  BCF    53.3
0D10:  BCF    53.4
0D12:  BSF    53.0
0D14:  ADDWF  01,F
0D16:  MOVF   01,W
0D18:  BTFSS  F9E.4
0D1A:  BRA    0D18
0D1C:  MOVWF  FAD
0D1E:  MOVFF  52,54
0D22:  MOVLW  0A
0D24:  MOVWF  55
0D26:  RCALL  0CC2
0D28:  MOVFF  00,52
0D2C:  MOVF   01,W
0D2E:  MOVLW  30
0D30:  BNZ   0D3E
0D32:  BTFSC  53.3
0D34:  BRA    0D48
0D36:  BTFSS  53.0
0D38:  BRA    0D48
0D3A:  BTFSC  53.4
0D3C:  MOVLW  20
0D3E:  ADDWF  01,F
0D40:  MOVF   01,W
0D42:  BTFSS  F9E.4
0D44:  BRA    0D42
0D46:  MOVWF  FAD
0D48:  MOVLW  30
0D4A:  ADDWF  52,F
0D4C:  MOVF   52,W
0D4E:  BTFSS  F9E.4
0D50:  BRA    0D4E
0D52:  MOVWF  FAD
0D54:  RETURN 0
0D56:  MOVFF  4F,56
0D5A:  MOVF   53,W
0D5C:  XORWF  56,F
0D5E:  BTFSS  56.7
0D60:  BRA    0D6C
0D62:  BCF    FD8.2
0D64:  BCF    FD8.0
0D66:  BTFSC  4F.7
0D68:  BSF    FD8.0
0D6A:  BRA    0DCA
0D6C:  MOVFF  4F,56
0D70:  MOVFF  52,57
0D74:  MOVF   4E,W
0D76:  SUBWF  57,F
0D78:  BZ    0D86
0D7A:  BTFSS  56.7
0D7C:  BRA    0DCA
0D7E:  MOVF   FD8,W
0D80:  XORLW  01
0D82:  MOVWF  FD8
0D84:  BRA    0DCA
0D86:  MOVFF  53,57
0D8A:  MOVF   4F,W
0D8C:  SUBWF  57,F
0D8E:  BZ    0D9C
0D90:  BTFSS  56.7
0D92:  BRA    0DCA
0D94:  MOVF   FD8,W
0D96:  XORLW  01
0D98:  MOVWF  FD8
0D9A:  BRA    0DCA
0D9C:  MOVFF  54,57
0DA0:  MOVF   50,W
0DA2:  SUBWF  57,F
0DA4:  BZ    0DB2
0DA6:  BTFSS  56.7
0DA8:  BRA    0DCA
0DAA:  MOVF   FD8,W
0DAC:  XORLW  01
0DAE:  MOVWF  FD8
0DB0:  BRA    0DCA
0DB2:  MOVFF  55,57
0DB6:  MOVF   51,W
0DB8:  SUBWF  57,F
0DBA:  BZ    0DC8
0DBC:  BTFSS  56.7
0DBE:  BRA    0DCA
0DC0:  MOVF   FD8,W
0DC2:  XORLW  01
0DC4:  MOVWF  FD8
0DC6:  BRA    0DCA
0DC8:  BCF    FD8.0
0DCA:  RETURN 0
*
0FAE:  MOVF   FE9,W
0FB0:  MOVWF  54
0FB2:  MOVLW  3B
0FB4:  MOVWF  5B
0FB6:  MOVLW  9A
0FB8:  MOVWF  5A
0FBA:  MOVLW  CA
0FBC:  MOVWF  59
0FBE:  CLRF   58
0FC0:  MOVLW  0A
0FC2:  MOVWF  56
0FC4:  BSF    FD8.1
0FC6:  CLRF   FEA
0FC8:  MOVLW  50
0FCA:  MOVWF  FE9
0FCC:  MOVFF  53,5F
0FD0:  MOVFF  52,5E
0FD4:  MOVFF  51,5D
0FD8:  MOVFF  50,5C
0FDC:  MOVFF  5B,63
0FE0:  MOVFF  5A,62
0FE4:  MOVFF  59,61
0FE8:  MOVFF  58,60
0FEC:  RCALL  0AB4
0FEE:  MOVF   01,W
0FF0:  MOVF   00,F
0FF2:  BNZ   1012
0FF4:  MOVF   56,W
0FF6:  XORLW  01
0FF8:  BZ    1012
0FFA:  MOVF   54,W
0FFC:  BZ    1014
0FFE:  ANDLW  0F
1000:  SUBWF  56,W
1002:  BZ    1006
1004:  BC    1020
1006:  BTFSC  54.7
1008:  BRA    1020
100A:  BTFSC  54.6
100C:  BRA    1014
100E:  MOVLW  20
1010:  BRA    1016
1012:  CLRF   54
1014:  MOVLW  30
1016:  ADDWF  00,F
1018:  MOVF   00,W
101A:  BTFSS  F9E.4
101C:  BRA    101A
101E:  MOVWF  FAD
1020:  BCF    FD8.1
1022:  MOVFF  5B,5F
1026:  MOVFF  5A,5E
102A:  MOVFF  59,5D
102E:  MOVFF  58,5C
1032:  CLRF   x63
1034:  CLRF   x62
1036:  CLRF   x61
1038:  MOVLW  0A
103A:  MOVWF  x60
103C:  RCALL  0AB4
103E:  MOVFF  03,5B
1042:  MOVFF  02,5A
1046:  MOVFF  01,59
104A:  MOVFF  00,58
104E:  DECFSZ 56,F
1050:  BRA    0FC4
1052:  RETURN 0
1054:  BTFSC  50.7
1056:  BRA    1078
1058:  MOVLW  0F
105A:  MOVWF  00
105C:  SWAPF  4F,W
105E:  ANDWF  00,F
1060:  MOVLW  0A
1062:  SUBWF  00,W
1064:  BC    106C
1066:  MOVLW  30
1068:  ADDWF  00,F
106A:  BRA    1070
106C:  MOVF   50,W
106E:  ADDWF  00,F
1070:  MOVF   00,W
1072:  BTFSS  F9E.4
1074:  BRA    1072
1076:  MOVWF  FAD
1078:  MOVLW  0F
107A:  ANDWF  4F,F
107C:  MOVLW  0A
107E:  SUBWF  4F,W
1080:  BC    1086
1082:  MOVLW  30
1084:  BRA    108A
1086:  BCF    50.7
1088:  MOVF   50,W
108A:  ADDWF  4F,F
108C:  MOVF   4F,W
108E:  BTFSS  F9E.4
1090:  BRA    108E
1092:  MOVWF  FAD
1094:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #device 18F2480*=16, ADC=8 
.................... #use delay(clock=20000000) 
*
0466:  CLRF   FEA
0468:  MOVLW  4F
046A:  MOVWF  FE9
046C:  MOVF   FEF,W
046E:  BZ    048A
0470:  MOVLW  06
0472:  MOVWF  01
0474:  CLRF   00
0476:  DECFSZ 00,F
0478:  BRA    0476
047A:  DECFSZ 01,F
047C:  BRA    0474
047E:  MOVLW  7B
0480:  MOVWF  00
0482:  DECFSZ 00,F
0484:  BRA    0482
0486:  DECFSZ FEF,F
0488:  BRA    0470
048A:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... //#use fast_io(c) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
038A:  MOVLW  04
038C:  MOVWF  4E
038E:  RCALL  0208
....................    can_set_baud(); 
0390:  BRA    022A
....................  
....................    RXB0CON=0; 
0392:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
0394:  MOVLW  9F
0396:  ANDWF  F60,W
0398:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
039A:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
039C:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
03A0:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
03A2:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
03A4:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
03A6:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
03A8:  MOVLW  0F
03AA:  MOVWF  5F
03AC:  MOVLW  1B
03AE:  MOVWF  5E
03B0:  CLRF   x63
03B2:  CLRF   x62
03B4:  CLRF   x61
03B6:  CLRF   x60
03B8:  MOVLW  01
03BA:  MOVWF  x64
03BC:  RCALL  025A
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
03BE:  MOVLW  0F
03C0:  MOVWF  5F
03C2:  MOVLW  03
03C4:  MOVWF  5E
03C6:  CLRF   x63
03C8:  CLRF   x62
03CA:  CLRF   x61
03CC:  CLRF   x60
03CE:  MOVLW  01
03D0:  MOVWF  x64
03D2:  RCALL  025A
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
03D4:  MOVLW  0F
03D6:  MOVWF  5F
03D8:  MOVLW  07
03DA:  MOVWF  5E
03DC:  CLRF   x63
03DE:  CLRF   x62
03E0:  CLRF   x61
03E2:  CLRF   x60
03E4:  MOVLW  01
03E6:  MOVWF  x64
03E8:  RCALL  025A
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
03EA:  MOVLW  0F
03EC:  MOVWF  5F
03EE:  MOVLW  1F
03F0:  MOVWF  5E
03F2:  CLRF   x63
03F4:  CLRF   x62
03F6:  CLRF   x61
03F8:  CLRF   x60
03FA:  MOVLW  01
03FC:  MOVWF  x64
03FE:  RCALL  025A
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
0400:  MOVLW  0F
0402:  MOVWF  5F
0404:  MOVLW  0B
0406:  MOVWF  5E
0408:  CLRF   x63
040A:  CLRF   x62
040C:  CLRF   x61
040E:  CLRF   x60
0410:  MOVLW  01
0412:  MOVWF  x64
0414:  RCALL  025A
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
0416:  MOVLW  0F
0418:  MOVWF  5F
041A:  MOVWF  5E
041C:  CLRF   x63
041E:  CLRF   x62
0420:  CLRF   x61
0422:  CLRF   x60
0424:  MOVLW  01
0426:  MOVWF  x64
0428:  RCALL  025A
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
042A:  MOVLW  0F
042C:  MOVWF  5F
042E:  MOVLW  13
0430:  MOVWF  5E
0432:  CLRF   x63
0434:  CLRF   x62
0436:  CLRF   x61
0438:  CLRF   x60
043A:  MOVLW  01
043C:  MOVWF  x64
043E:  RCALL  025A
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0440:  MOVLW  0F
0442:  MOVWF  5F
0444:  MOVLW  17
0446:  MOVWF  5E
0448:  CLRF   x63
044A:  CLRF   x62
044C:  CLRF   x61
044E:  CLRF   x60
0450:  MOVLW  01
0452:  MOVWF  x64
0454:  RCALL  025A
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
0456:  MOVF   F93,W
0458:  ANDLW  FB
045A:  IORLW  08
045C:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
045E:  CLRF   4E
0460:  RCALL  0208
0462:  GOTO   1220 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
022A:  MOVLW  C0
022C:  ANDWF  F70,W
022E:  IORLW  04
0230:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0232:  MOVLW  3F
0234:  ANDWF  F70,W
0236:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
0238:  MOVLW  F8
023A:  ANDWF  F71,W
023C:  IORLW  02
023E:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
0240:  MOVLW  C7
0242:  ANDWF  F71,W
0244:  IORLW  28
0246:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
0248:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
024A:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
024C:  MOVLW  F8
024E:  ANDWF  F72,W
0250:  IORLW  05
0252:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0254:  BCF    F72.6
0256:  GOTO   0392 (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
0208:  SWAPF  4E,W
020A:  ANDLW  70
020C:  MOVWF  00
020E:  BCF    FD8.0
0210:  RLCF   00,F
0212:  MOVLW  1F
0214:  ANDWF  F6F,W
0216:  IORWF  00,W
0218:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
021A:  MOVFF  F6E,00
021E:  SWAPF  00,F
0220:  RRCF   00,W
0222:  ANDLW  07
0224:  SUBWF  4E,W
0226:  BNZ   021A
0228:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
025A:  MOVFF  5F,66
025E:  MOVFF  5E,65
....................  
....................    if (ext) {  //extended 
0262:  MOVF   x64,F
0264:  BZ    030A
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0266:  MOVFF  65,FE9
026A:  MOVFF  66,FEA
026E:  MOVFF  60,FEF
....................  
....................       //eidh 
....................       ptr--; 
0272:  MOVF   x65,W
0274:  BTFSC  FD8.2
0276:  DECF   x66,F
0278:  DECF   x65,F
....................       *ptr=make8(id,1); //8:15 
027A:  MOVFF  65,FE9
027E:  MOVFF  66,FEA
0282:  MOVFF  61,FEF
....................  
....................       //sidl 
....................       ptr--; 
0286:  MOVF   x65,W
0288:  BTFSC  FD8.2
028A:  DECF   x66,F
028C:  DECF   x65,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
028E:  MOVFF  65,FE9
0292:  MOVFF  66,FEA
0296:  MOVF   x62,W
0298:  ANDLW  03
029A:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
029C:  MOVFF  65,FE9
02A0:  MOVFF  66,FEA
02A4:  MOVFF  62,00
02A8:  RLCF   00,F
02AA:  RLCF   00,F
02AC:  RLCF   00,F
02AE:  MOVLW  F8
02B0:  ANDWF  00,F
02B2:  MOVF   00,W
02B4:  ANDLW  E0
02B6:  IORWF  FEF,W
02B8:  MOVWF  FEF
....................       *ptr|=0x08; 
02BA:  MOVFF  65,FE9
02BE:  MOVFF  66,FEA
02C2:  MOVF   FEF,W
02C4:  IORLW  08
02C6:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
02C8:  MOVF   x65,W
02CA:  BTFSC  FD8.2
02CC:  DECF   x66,F
02CE:  DECF   x65,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
02D0:  MOVFF  65,FE9
02D4:  MOVFF  66,FEA
02D8:  MOVFF  62,00
02DC:  SWAPF  00,F
02DE:  RRCF   00,F
02E0:  MOVLW  07
02E2:  ANDWF  00,F
02E4:  MOVF   00,W
02E6:  ANDLW  07
02E8:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
02EA:  MOVFF  65,FE9
02EE:  MOVFF  66,FEA
02F2:  MOVFF  63,00
02F6:  RLCF   00,F
02F8:  RLCF   00,F
02FA:  RLCF   00,F
02FC:  MOVLW  F8
02FE:  ANDWF  00,F
0300:  MOVF   00,W
0302:  ANDLW  F8
0304:  IORWF  FEF,W
0306:  MOVWF  FEF
....................    } 
0308:  BRA    0388
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
030A:  MOVFF  65,FE9
030E:  MOVFF  66,FEA
0312:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0314:  MOVF   x65,W
0316:  BTFSC  FD8.2
0318:  DECF   x66,F
031A:  DECF   x65,F
....................       *ptr=0; 
031C:  MOVFF  65,FE9
0320:  MOVFF  66,FEA
0324:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
0326:  MOVF   x65,W
0328:  BTFSC  FD8.2
032A:  DECF   x66,F
032C:  DECF   x65,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
032E:  MOVFF  65,FE9
0332:  MOVFF  66,FEA
0336:  MOVFF  60,00
033A:  SWAPF  00,F
033C:  RLCF   00,F
033E:  MOVLW  E0
0340:  ANDWF  00,F
0342:  MOVF   00,W
0344:  ANDLW  E0
0346:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
0348:  MOVF   x65,W
034A:  BTFSC  FD8.2
034C:  DECF   x66,F
034E:  DECF   x65,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0350:  MOVFF  65,FE9
0354:  MOVFF  66,FEA
0358:  MOVFF  60,00
035C:  RRCF   00,F
035E:  RRCF   00,F
0360:  RRCF   00,F
0362:  MOVLW  1F
0364:  ANDWF  00,F
0366:  MOVF   00,W
0368:  ANDLW  1F
036A:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
036C:  MOVFF  65,FE9
0370:  MOVFF  66,FEA
0374:  MOVFF  61,00
0378:  SWAPF  00,F
037A:  RLCF   00,F
037C:  MOVLW  E0
037E:  ANDWF  00,F
0380:  MOVF   00,W
0382:  ANDLW  E0
0384:  IORWF  FEF,W
0386:  MOVWF  FEF
....................    } 
0388:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
0DCC:  CLRF   x60
0DCE:  CLRF   5F
0DD0:  CLRF   5E
0DD2:  CLRF   5D
....................    ptr=addr; 
0DD4:  MOVFF  5B,62
0DD8:  MOVFF  5A,61
....................  
....................    if (ext) { 
0DDC:  MOVF   5C,F
0DDE:  BTFSC  FD8.2
0DE0:  BRA    0EF4
....................       ret=*ptr;  //eidl 
0DE2:  MOVFF  61,FE9
0DE6:  MOVFF  62,FEA
0DEA:  CLRF   x60
0DEC:  CLRF   5F
0DEE:  CLRF   5E
0DF0:  MOVFF  FEF,5D
....................  
....................       ptr--;     //eidh 
0DF4:  MOVF   x61,W
0DF6:  BTFSC  FD8.2
0DF8:  DECF   x62,F
0DFA:  DECF   x61,F
....................       ret|=((unsigned int32)*ptr << 8); 
0DFC:  MOVFF  61,FE9
0E00:  MOVFF  62,FEA
0E04:  MOVF   FEF,W
0E06:  CLRF   x65
0E08:  CLRF   x64
0E0A:  MOVWF  x63
0E0C:  CLRF   00
0E0E:  MOVF   00,W
0E10:  IORWF  5D,F
0E12:  MOVF   x63,W
0E14:  IORWF  5E,F
0E16:  MOVF   x64,W
0E18:  IORWF  5F,F
0E1A:  MOVF   x65,W
0E1C:  IORWF  x60,F
....................  
....................       ptr--;     //sidl 
0E1E:  MOVF   x61,W
0E20:  BTFSC  FD8.2
0E22:  DECF   x62,F
0E24:  DECF   x61,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
0E26:  MOVFF  61,FE9
0E2A:  MOVFF  62,FEA
0E2E:  MOVF   FEF,W
0E30:  CLRF   x66
0E32:  CLRF   x65
0E34:  CLRF   x64
0E36:  MOVWF  x63
0E38:  MOVLW  03
0E3A:  ANDWF  x63,F
0E3C:  CLRF   x64
0E3E:  CLRF   x65
0E40:  CLRF   x66
0E42:  CLRF   00
0E44:  CLRF   01
0E46:  MOVF   00,W
0E48:  IORWF  5D,F
0E4A:  MOVF   01,W
0E4C:  IORWF  5E,F
0E4E:  MOVF   x63,W
0E50:  IORWF  5F,F
0E52:  MOVF   x64,W
0E54:  IORWF  x60,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
0E56:  MOVFF  61,FE9
0E5A:  MOVFF  62,FEA
0E5E:  MOVF   FEF,W
0E60:  CLRF   x66
0E62:  CLRF   x65
0E64:  CLRF   x64
0E66:  MOVWF  x63
0E68:  MOVLW  E0
0E6A:  ANDWF  x63,F
0E6C:  CLRF   x64
0E6E:  CLRF   x65
0E70:  CLRF   x66
0E72:  CLRF   00
0E74:  RLCF   x63,W
0E76:  MOVWF  01
0E78:  RLCF   x64,W
0E7A:  MOVWF  02
0E7C:  RLCF   x65,W
0E7E:  MOVWF  03
0E80:  RLCF   01,F
0E82:  RLCF   02,F
0E84:  RLCF   03,F
0E86:  RLCF   01,F
0E88:  RLCF   02,F
0E8A:  RLCF   03,F
0E8C:  RLCF   01,F
0E8E:  RLCF   02,F
0E90:  RLCF   03,F
0E92:  RLCF   01,F
0E94:  RLCF   02,F
0E96:  RLCF   03,F
0E98:  MOVLW  E0
0E9A:  ANDWF  01,F
0E9C:  MOVF   00,W
0E9E:  IORWF  5D,F
0EA0:  MOVF   01,W
0EA2:  IORWF  5E,F
0EA4:  MOVF   02,W
0EA6:  IORWF  5F,F
0EA8:  MOVF   03,W
0EAA:  IORWF  x60,F
....................  
....................       ptr--;     //sidh 
0EAC:  MOVF   x61,W
0EAE:  BTFSC  FD8.2
0EB0:  DECF   x62,F
0EB2:  DECF   x61,F
....................       ret|=((unsigned int32)*ptr << 21); 
0EB4:  MOVFF  61,FE9
0EB8:  MOVFF  62,FEA
0EBC:  MOVF   FEF,W
0EBE:  CLRF   x64
0EC0:  MOVWF  x63
0EC2:  CLRF   00
0EC4:  CLRF   01
0EC6:  RLCF   x63,W
0EC8:  MOVWF  02
0ECA:  RLCF   x64,W
0ECC:  MOVWF  03
0ECE:  RLCF   02,F
0ED0:  RLCF   03,F
0ED2:  RLCF   02,F
0ED4:  RLCF   03,F
0ED6:  RLCF   02,F
0ED8:  RLCF   03,F
0EDA:  RLCF   02,F
0EDC:  RLCF   03,F
0EDE:  MOVLW  E0
0EE0:  ANDWF  02,F
0EE2:  MOVF   00,W
0EE4:  IORWF  5D,F
0EE6:  MOVF   01,W
0EE8:  IORWF  5E,F
0EEA:  MOVF   02,W
0EEC:  IORWF  5F,F
0EEE:  MOVF   03,W
0EF0:  IORWF  x60,F
....................  
....................    } 
0EF2:  BRA    0F9A
....................    else { 
....................       ptr-=2;    //sidl 
0EF4:  MOVLW  02
0EF6:  SUBWF  x61,F
0EF8:  MOVLW  00
0EFA:  SUBWFB x62,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
0EFC:  MOVFF  61,FE9
0F00:  MOVFF  62,FEA
0F04:  MOVF   FEF,W
0F06:  CLRF   x66
0F08:  CLRF   x65
0F0A:  CLRF   x64
0F0C:  MOVWF  x63
0F0E:  MOVLW  E0
0F10:  ANDWF  x63,F
0F12:  CLRF   x64
0F14:  CLRF   x65
0F16:  CLRF   x66
0F18:  RRCF   x66,W
0F1A:  MOVWF  x60
0F1C:  RRCF   x65,W
0F1E:  MOVWF  5F
0F20:  RRCF   x64,W
0F22:  MOVWF  5E
0F24:  RRCF   x63,W
0F26:  MOVWF  5D
0F28:  RRCF   x60,F
0F2A:  RRCF   5F,F
0F2C:  RRCF   5E,F
0F2E:  RRCF   5D,F
0F30:  RRCF   x60,F
0F32:  RRCF   5F,F
0F34:  RRCF   5E,F
0F36:  RRCF   5D,F
0F38:  RRCF   x60,F
0F3A:  RRCF   5F,F
0F3C:  RRCF   5E,F
0F3E:  RRCF   5D,F
0F40:  RRCF   x60,F
0F42:  RRCF   5F,F
0F44:  RRCF   5E,F
0F46:  RRCF   5D,F
0F48:  MOVLW  07
0F4A:  ANDWF  x60,F
....................  
....................       ptr--;     //sidh 
0F4C:  MOVF   x61,W
0F4E:  BTFSC  FD8.2
0F50:  DECF   x62,F
0F52:  DECF   x61,F
....................       ret|=((unsigned int32)*ptr << 3); 
0F54:  MOVFF  61,FE9
0F58:  MOVFF  62,FEA
0F5C:  MOVF   FEF,W
0F5E:  CLRF   x66
0F60:  CLRF   x65
0F62:  CLRF   x64
0F64:  MOVWF  x63
0F66:  RLCF   x63,W
0F68:  MOVWF  00
0F6A:  RLCF   x64,W
0F6C:  MOVWF  01
0F6E:  RLCF   x65,W
0F70:  MOVWF  02
0F72:  RLCF   x66,W
0F74:  MOVWF  03
0F76:  RLCF   00,F
0F78:  RLCF   01,F
0F7A:  RLCF   02,F
0F7C:  RLCF   03,F
0F7E:  RLCF   00,F
0F80:  RLCF   01,F
0F82:  RLCF   02,F
0F84:  RLCF   03,F
0F86:  MOVLW  F8
0F88:  ANDWF  00,F
0F8A:  MOVF   00,W
0F8C:  IORWF  5D,F
0F8E:  MOVF   01,W
0F90:  IORWF  5E,F
0F92:  MOVF   02,W
0F94:  IORWF  5F,F
0F96:  MOVF   03,W
0F98:  IORWF  x60,F
....................    } 
....................  
....................    return(ret); 
0F9A:  MOVFF  5D,00
0F9E:  MOVFF  5E,01
0FA2:  MOVFF  5F,02
0FA6:  MOVFF  60,03
0FAA:  GOTO   1812 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
1096:  MOVLW  0F
1098:  MOVWF  5C
109A:  MOVLW  66
109C:  MOVWF  5B
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
109E:  MOVLB  F
10A0:  BTFSC  x40.3
10A2:  BRA    10B0
....................       CANCON.win=CAN_WIN_TX0; 
10A4:  MOVLW  F1
10A6:  ANDWF  F6F,W
10A8:  IORLW  08
10AA:  MOVWF  F6F
....................       port=0; 
10AC:  CLRF   5D
....................    } 
10AE:  BRA    10DA
....................    else if (!TXB1CON.txreq) { 
10B0:  BTFSC  x30.3
10B2:  BRA    10C2
....................       CANCON.win=CAN_WIN_TX1; 
10B4:  MOVLW  F1
10B6:  ANDWF  F6F,W
10B8:  IORLW  06
10BA:  MOVWF  F6F
....................       port=1; 
10BC:  MOVLW  01
10BE:  MOVWF  5D
....................    } 
10C0:  BRA    10DA
....................    else if (!TXB2CON.txreq) { 
10C2:  BTFSC  x20.3
10C4:  BRA    10D4
....................       CANCON.win=CAN_WIN_TX2; 
10C6:  MOVLW  F1
10C8:  ANDWF  F6F,W
10CA:  IORLW  04
10CC:  MOVWF  F6F
....................       port=2; 
10CE:  MOVLW  02
10D0:  MOVWF  5D
....................    } 
10D2:  BRA    10DA
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
10D4:  MOVLW  00
10D6:  MOVWF  01
10D8:  BRA    1152
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
10DA:  MOVF   57,W
10DC:  ANDLW  03
10DE:  MOVWF  00
10E0:  MOVLW  FC
10E2:  ANDWF  F60,W
10E4:  IORWF  00,W
10E6:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
10E8:  MOVLW  0F
10EA:  MOVWF  5F
10EC:  MOVLW  64
10EE:  MOVWF  5E
10F0:  MOVFF  53,63
10F4:  MOVFF  52,62
10F8:  MOVFF  51,61
10FC:  MOVFF  50,60
1100:  MOVFF  58,64
1104:  MOVLB  0
1106:  CALL   025A
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
110A:  MOVFF  56,F65
....................    TXBaDLC.rtr=rtr; 
110E:  BCF    F65.6
1110:  BTFSC  59.0
1112:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
1114:  CLRF   5A
1116:  MOVF   56,W
1118:  SUBWF  5A,W
111A:  BC    1144
....................       *txd0=*data; 
111C:  MOVFF  54,FE9
1120:  MOVFF  55,FEA
1124:  MOVFF  FEF,60
1128:  MOVFF  5C,FEA
112C:  MOVFF  5B,FE9
1130:  MOVFF  60,FEF
....................       txd0++; 
1134:  INCF   5B,F
1136:  BTFSC  FD8.2
1138:  INCF   5C,F
....................       data++; 
113A:  INCF   54,F
113C:  BTFSC  FD8.2
113E:  INCF   55,F
1140:  INCF   5A,F
1142:  BRA    1116
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
1144:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
1146:  MOVLW  F1
1148:  ANDWF  F6F,W
114A:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
114C:  MOVLW  01
114E:  MOVWF  01
1150:  MOVLB  F
1152:  MOVLB  0
1154:  GOTO   1A6C (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
177E:  BTFSS  F60.7
1780:  BRA    17B0
....................         CANCON.win=CAN_WIN_RX0; 
1782:  MOVLW  F1
1784:  ANDWF  F6F,W
1786:  MOVWF  F6F
....................         stat.buffer=0; 
1788:  BCF    1E.4
....................  
....................         CAN_INT_RXB0IF=0; 
178A:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
178C:  BCF    1E.0
178E:  BTFSC  F74.7
1790:  BSF    1E.0
....................         COMSTAT.rx0ovfl=0; 
1792:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
1794:  BTFSS  F60.2
1796:  BRA    17AE
....................          stat.filthit=RXB0CON.filthit0; 
1798:  MOVLW  00
179A:  BTFSC  F60.0
179C:  MOVLW  01
179E:  ANDLW  07
17A0:  MOVWF  00
17A2:  BCF    FD8.0
17A4:  RLCF   00,F
17A6:  MOVLW  F1
17A8:  ANDWF  1E,W
17AA:  IORWF  00,W
17AC:  MOVWF  1E
....................         } 
....................     } 
17AE:  BRA    17E8
....................     else if ( RXB1CON.rxful ) 
17B0:  MOVLB  F
17B2:  BTFSS  x50.7
17B4:  BRA    17E0
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
17B6:  MOVLW  F1
17B8:  ANDWF  F6F,W
17BA:  IORLW  0A
17BC:  MOVWF  F6F
....................         stat.buffer=1; 
17BE:  BSF    1E.4
....................  
....................         CAN_INT_RXB1IF=0; 
17C0:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
17C2:  BCF    1E.0
17C4:  BTFSC  F74.6
17C6:  BSF    1E.0
....................         COMSTAT.rx1ovfl=0; 
17C8:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
17CA:  MOVF   x50,W
17CC:  ANDLW  07
17CE:  ANDLW  07
17D0:  MOVWF  00
17D2:  BCF    FD8.0
17D4:  RLCF   00,F
17D6:  MOVLW  F1
17D8:  ANDWF  1E,W
17DA:  IORWF  00,W
17DC:  MOVWF  1E
....................     } 
17DE:  BRA    17E6
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
17E0:  MOVLW  00
17E2:  MOVWF  01
17E4:  BRA    187C
17E6:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
17E8:  MOVF   F65,W
17EA:  ANDLW  0F
17EC:  MOVWF  2B
....................     stat.rtr=RXBaDLC.rtr; 
17EE:  BCF    1E.5
17F0:  BTFSC  F65.6
17F2:  BSF    1E.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
17F4:  BCF    1E.6
17F6:  BTFSC  F62.3
17F8:  BSF    1E.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
17FA:  MOVLW  00
17FC:  BTFSC  1E.6
17FE:  MOVLW  01
1800:  MOVWF  53
1802:  MOVLW  0F
1804:  MOVWF  5B
1806:  MOVLW  64
1808:  MOVWF  5A
180A:  MOVFF  53,5C
180E:  GOTO   0DCC
1812:  MOVFF  03,22
1816:  MOVFF  02,21
181A:  MOVFF  01,20
181E:  MOVFF  00,1F
....................  
....................     ptr = &TXRXBaD0; 
1822:  MOVLW  0F
1824:  MOVWF  52
1826:  MOVLW  66
1828:  MOVWF  51
....................     for ( i = 0; i < len; i++ ) { 
182A:  CLRF   50
182C:  MOVF   2B,W
182E:  SUBWF  50,W
1830:  BC    185A
....................         *data = *ptr; 
1832:  MOVFF  51,FE9
1836:  MOVFF  52,FEA
183A:  MOVFF  FEF,55
183E:  MOVFF  4F,FEA
1842:  MOVFF  4E,FE9
1846:  MOVFF  55,FEF
....................         data++; 
184A:  INCF   4E,F
184C:  BTFSC  FD8.2
184E:  INCF   4F,F
....................         ptr++; 
1850:  INCF   51,F
1852:  BTFSC  FD8.2
1854:  INCF   52,F
1856:  INCF   50,F
1858:  BRA    182C
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
185A:  MOVLW  F1
185C:  ANDWF  F6F,W
185E:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
1860:  BCF    1E.7
1862:  BTFSC  FA4.7
1864:  BSF    1E.7
....................     CAN_INT_IRXIF = 0; 
1866:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
1868:  BTFSS  1E.4
186A:  BRA    1874
....................       RXB1CON.rxful=0; 
186C:  MOVLB  F
186E:  BCF    x50.7
....................     } 
1870:  BRA    1878
1872:  MOVLB  0
....................     else { 
....................       RXB0CON.rxful=0; 
1874:  BCF    F60.7
1876:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
1878:  MOVLW  01
187A:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... //#include <BME280.c> 
.................... #include <sht71.c> 
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       //  
.................... //                                                                           //  
.................... // ***** To initialise SHT75 sensor upon power up *****                      //  
.................... //                                                                           //  
.................... // Function : sht_init()                                                     //  
.................... // Return   : none                                                           //  
.................... //                                                                           //  
.................... //                                                                           //  
.................... // ***** To measure and caluculate SHT75 temp & real RH *****                //  
.................... //                                                                           //  
.................... // Function : sht_rd (temp, truehumid)                                       //  
.................... // Return   : temperature & true humidity in float values                    //  
.................... //                                                                           //  
.................... ///////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define sht_data_pin   PIN_B7  // cu cua pic16f887 la PIN_D7 
.................... #define sht_clk_pin    PIN_B6  // cu cua pic16f887 la PIN_D6 
....................  
....................  
.................... //***** Function to alert SHT75 *****  
....................  
.................... void comstart (void)  
.................... {  
....................  output_float(sht_data_pin);  //data high  
*
048C:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);  //clk low  
048E:  BCF    F8A.6
0490:  BCF    F93.6
....................  delay_us(1);  
0492:  BRA    0494
0494:  BRA    0496
0496:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0498:  BSF    F8A.6
049A:  BCF    F93.6
....................  delay_us(1);  
049C:  BRA    049E
049E:  BRA    04A0
04A0:  NOP   
....................  output_bit(sht_data_pin, 0); //data low  
04A2:  BCF    F8A.7
04A4:  BCF    F93.7
....................  delay_us(1);  
04A6:  BRA    04A8
04A8:  BRA    04AA
04AA:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
04AC:  BCF    F8A.6
04AE:  BCF    F93.6
....................  delay_us(2);  
04B0:  MOVLW  02
04B2:  MOVWF  00
04B4:  DECFSZ 00,F
04B6:  BRA    04B4
04B8:  BRA    04BA
04BA:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
04BC:  BSF    F8A.6
04BE:  BCF    F93.6
....................  delay_us(1);  
04C0:  BRA    04C2
04C2:  BRA    04C4
04C4:  NOP   
....................  output_float(sht_data_pin);  //data high  
04C6:  BSF    F93.7
....................  delay_us(1);  
04C8:  BRA    04CA
04CA:  BRA    04CC
04CC:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
04CE:  BCF    F8A.6
04D0:  BCF    F93.6
04D2:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to write data to SHT75 *****  
....................  
.................... int1 comwrite (int8 iobyte)  
*
0524:  MOVLW  80
0526:  MOVWF  x63
.................... {  
....................  int8 i, mask = 0x80;  
....................  int1 ack;  
....................  
....................  //Shift out command  
....................  delay_us(4);  
0528:  MOVLW  06
052A:  MOVWF  00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  NOP   
....................  for(i=0; i<8; i++)  
0532:  CLRF   x62
0534:  MOVF   x62,W
0536:  SUBLW  07
0538:  BNC   0564
....................   {  
....................    output_bit(sht_clk_pin, 0);                          //clk low  
053A:  BCF    F8A.6
053C:  BCF    F93.6
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high  
053E:  MOVF   x61,W
0540:  ANDWF  x63,W
0542:  BZ    0548
0544:  BSF    F93.7
0546:  BRA    054C
....................    else output_bit(sht_data_pin, 0);                    //data low if MSB low  
0548:  BCF    F8A.7
054A:  BCF    F93.7
....................    delay_us(1);  
054C:  BRA    054E
054E:  BRA    0550
0550:  NOP   
....................    output_bit(sht_clk_pin, 1);                          //clk high  
0552:  BSF    F8A.6
0554:  BCF    F93.6
....................    delay_us(1);  
0556:  BRA    0558
0558:  BRA    055A
055A:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit  
055C:  BCF    FD8.0
055E:  RRCF   x63,F
0560:  INCF   x62,F
0562:  BRA    0534
....................   }  
....................  
....................  //Shift in ack  
....................  output_bit(sht_clk_pin, 0);  //clk low  
0564:  BCF    F8A.6
0566:  BCF    F93.6
....................  delay_us(1);  
0568:  BRA    056A
056A:  BRA    056C
056C:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit  
056E:  BSF    F93.7
0570:  BCF    x64.0
0572:  BTFSC  F81.7
0574:  BSF    x64.0
....................  output_bit(sht_clk_pin, 1);  //clk high  
0576:  BSF    F8A.6
0578:  BCF    F93.6
....................  delay_us(1);  
057A:  BRA    057C
057C:  BRA    057E
057E:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0580:  BCF    F8A.6
0582:  BCF    F93.6
....................  return(ack);  
0584:  MOVLW  00
0586:  BTFSC  x64.0
0588:  MOVLW  01
058A:  MOVWF  01
058C:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to read data from SHT75 *****  
....................  
.................... int16 comread (void)  
*
05C6:  CLRF   x63
05C8:  CLRF   x62
.................... {  
....................  int8 i;  
....................  int16 iobyte = 0;  
....................  const int16 mask0 = 0x0000;  
....................  const int16 mask1 = 0x0001;  
....................  
....................  //shift in MSB data  
....................  for(i=0; i<8; i++)  
05CA:  CLRF   x61
05CC:  MOVF   x61,W
05CE:  SUBLW  07
05D0:  BNC   05F8
....................   {  
....................    iobyte = iobyte << 1;  
05D2:  BCF    FD8.0
05D4:  RLCF   x62,F
05D6:  RLCF   x63,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
05D8:  BSF    F8A.6
05DA:  BCF    F93.6
....................    delay_us(1);  
05DC:  BRA    05DE
05DE:  BRA    05E0
05E0:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
05E2:  BSF    F93.7
05E4:  BTFSS  F81.7
05E6:  BRA    05EA
05E8:  BSF    x62.0
....................    else iobyte |= mask0;  
....................    output_bit(sht_clk_pin, 0);                //clk low  
05EA:  BCF    F8A.6
05EC:  BCF    F93.6
....................    delay_us(1);  
05EE:  BRA    05F0
05F0:  BRA    05F2
05F2:  NOP   
05F4:  INCF   x61,F
05F6:  BRA    05CC
....................   }  
....................  
....................  //send ack 0 bit  
....................  output_bit(sht_data_pin, 0); //data low  
05F8:  BCF    F8A.7
05FA:  BCF    F93.7
....................  delay_us(1);  
05FC:  BRA    05FE
05FE:  BRA    0600
0600:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0602:  BSF    F8A.6
0604:  BCF    F93.6
....................  delay_us(2);  
0606:  MOVLW  02
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  BRA    0610
0610:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0612:  BCF    F8A.6
0614:  BCF    F93.6
....................  delay_us(1);  
0616:  BRA    0618
0618:  BRA    061A
061A:  NOP   
....................  output_float(sht_data_pin);  //data high  
061C:  BSF    F93.7
....................  
....................  //shift in LSB data  
....................  for(i=0; i<8; i++)  
061E:  CLRF   x61
0620:  MOVF   x61,W
0622:  SUBLW  07
0624:  BNC   064C
....................   {  
....................    iobyte = iobyte << 1;  
0626:  BCF    FD8.0
0628:  RLCF   x62,F
062A:  RLCF   x63,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
062C:  BSF    F8A.6
062E:  BCF    F93.6
....................    delay_us(1);  
0630:  BRA    0632
0632:  BRA    0634
0634:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
0636:  BSF    F93.7
0638:  BTFSS  F81.7
063A:  BRA    063E
063C:  BSF    x62.0
....................    else iobyte |= mask0;  
....................    output_bit(sht_clk_pin, 0);                //clk low  
063E:  BCF    F8A.6
0640:  BCF    F93.6
....................    delay_us(1);  
0642:  BRA    0644
0644:  BRA    0646
0646:  NOP   
0648:  INCF   x61,F
064A:  BRA    0620
....................   }  
....................  
....................  //send ack 1 bit  
....................  output_float(sht_data_pin);  //data high  
064C:  BSF    F93.7
....................  delay_us(1);  
064E:  BRA    0650
0650:  BRA    0652
0652:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0654:  BSF    F8A.6
0656:  BCF    F93.6
....................  delay_us(2);  
0658:  MOVLW  02
065A:  MOVWF  00
065C:  DECFSZ 00,F
065E:  BRA    065C
0660:  BRA    0662
0662:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0664:  BCF    F8A.6
0666:  BCF    F93.6
....................  
....................  return(iobyte);  
0668:  MOVFF  62,01
066C:  MOVFF  63,02
0670:  RETURN 0
.................... }  
....................  
.................... //***** Function to wait for SHT75 reading *****  
....................  
.................... void comwait (void)  
.................... {  
....................  int16 sht_delay;  
....................  
....................  output_float(sht_data_pin);                     //data high  
*
058E:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);                     //clk low  
0590:  BCF    F8A.6
0592:  BCF    F93.6
....................  delay_us(1);  
0594:  BRA    0596
0596:  BRA    0598
0598:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms  
059A:  CLRF   x62
059C:  CLRF   x61
059E:  MOVF   x62,W
05A0:  SUBLW  75
05A2:  BNC   05C4
05A4:  BNZ   05AC
05A6:  MOVF   x61,W
05A8:  SUBLW  2F
05AA:  BNC   05C4
....................   {  
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready  
05AC:  BSF    F93.7
05AE:  BTFSS  F81.7
05B0:  BRA    05C4
....................    delay_us(10);  
05B2:  MOVLW  10
05B4:  MOVWF  00
05B6:  DECFSZ 00,F
05B8:  BRA    05B6
05BA:  NOP   
05BC:  INCF   x61,F
05BE:  BTFSC  FD8.2
05C0:  INCF   x62,F
05C2:  BRA    059E
....................   }  
05C4:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to reset SHT75 communication *****  
....................  
....................  
.................... void comreset (void)  
.................... {  
....................  int8 i;  
....................  
....................  output_float(sht_data_pin);    //data high  
*
04D4:  BSF    F93.7
....................  output_bit(sht_clk_pin, 0);    //clk low  
04D6:  BCF    F8A.6
04D8:  BCF    F93.6
....................  delay_us(2);  
04DA:  MOVLW  02
04DC:  MOVWF  00
04DE:  DECFSZ 00,F
04E0:  BRA    04DE
04E2:  BRA    04E4
04E4:  NOP   
....................  for(i=0; i<9; i++)  
04E6:  CLRF   4E
04E8:  MOVF   4E,W
04EA:  SUBLW  08
04EC:  BNC   0512
....................   {  
....................    output_bit(sht_clk_pin, 1);  //toggle clk 9 times  
04EE:  BSF    F8A.6
04F0:  BCF    F93.6
....................    delay_us(2);  
04F2:  MOVLW  02
04F4:  MOVWF  00
04F6:  DECFSZ 00,F
04F8:  BRA    04F6
04FA:  BRA    04FC
04FC:  NOP   
....................    output_bit(sht_clk_pin, 0);  
04FE:  BCF    F8A.6
0500:  BCF    F93.6
....................    delay_us(2);  
0502:  MOVLW  02
0504:  MOVWF  00
0506:  DECFSZ 00,F
0508:  BRA    0506
050A:  BRA    050C
050C:  NOP   
050E:  INCF   4E,F
0510:  BRA    04E8
....................  }  
....................  comstart();  
0512:  RCALL  048C
0514:  GOTO   051A (RETURN)
.................... }  
....................  
....................  
.................... //***** Function to soft reset SHT75 *****  
....................  
.................... void sht_soft_reset (void)  
.................... {  
....................  comreset();           //SHT75 communication reset  
....................  comwrite(0x1e);       //send SHT75 reset command  
....................  delay_ms(15);         //pause 15 ms  
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 temperature *****  
....................  
.................... int16 measuretemp()  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();             //alert SHT75  
*
0672:  RCALL  048C
....................  ack = comwrite(0x03);   //send measure temp command and read ack status  
0674:  MOVLW  03
0676:  MOVWF  x61
0678:  RCALL  0524
067A:  BCF    5E.0
067C:  BTFSC  01.0
067E:  BSF    5E.0
....................  if(ack == 1) return;  
0680:  BTFSC  5E.0
0682:  BRA    0698
....................  comwait();              //wait for SHT75 measurement to complete  
0684:  RCALL  058E
....................  iobyte = comread();     //read SHT75 temp data  
0686:  RCALL  05C6
0688:  MOVFF  02,60
068C:  MOVFF  01,5F
....................  return(iobyte);  
0690:  MOVFF  5F,01
0694:  MOVFF  60,02
0698:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 RH *****  
....................  
.................... int16 measurehumid (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();            //alert SHT75  
*
06D0:  RCALL  048C
....................  ack = comwrite(0x05);  //send measure RH command and read ack status  
06D2:  MOVLW  05
06D4:  MOVWF  x61
06D6:  RCALL  0524
06D8:  BCF    5E.0
06DA:  BTFSC  01.0
06DC:  BSF    5E.0
....................  if(ack == 1) return;  
06DE:  BTFSC  5E.0
06E0:  BRA    06F6
....................  comwait();             //wait for SHT75 measurement to complete  
06E2:  RCALL  058E
....................  iobyte = comread();    //read SHT75 temp data  
06E4:  RCALL  05C6
06E6:  MOVFF  02,60
06EA:  MOVFF  01,5F
....................  return(iobyte);  
06EE:  MOVFF  5F,01
06F2:  MOVFF  60,02
06F6:  RETURN 0
.................... }  
....................  
....................  
.................... //***** Function to calculate SHT75 temp & RH *****  
....................  
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue)  
.................... {  
....................  float rh;  
....................  
....................  //calculate temperature reading  
....................  tc = ((float) temp * 0.01) - 40.0;  
*
12BA:  MOVFF  5F,73
12BE:  MOVFF  5E,72
12C2:  CALL   069A
12C6:  MOVFF  03,69
12CA:  MOVFF  02,68
12CE:  MOVFF  01,67
12D2:  MOVFF  00,66
12D6:  MOVFF  03,7D
12DA:  MOVFF  02,7C
12DE:  MOVFF  01,7B
12E2:  MOVFF  00,7A
12E6:  MOVLW  0A
12E8:  MOVWF  x81
12EA:  MOVLW  D7
12EC:  MOVWF  x80
12EE:  MOVLW  23
12F0:  MOVWF  x7F
12F2:  MOVLW  78
12F4:  MOVWF  x7E
12F6:  CALL   06F8
12FA:  MOVFF  03,69
12FE:  MOVFF  02,68
1302:  MOVFF  01,67
1306:  MOVFF  00,66
130A:  BSF    FD8.1
130C:  MOVFF  03,79
1310:  MOVFF  02,78
1314:  MOVFF  01,77
1318:  MOVFF  00,76
131C:  CLRF   x7D
131E:  CLRF   x7C
1320:  MOVLW  20
1322:  MOVWF  x7B
1324:  MOVLW  84
1326:  MOVWF  x7A
1328:  CALL   07EA
132C:  MOVFF  03,49
1330:  MOVFF  02,48
1334:  MOVFF  01,47
1338:  MOVFF  00,46
....................  
....................  //calculate Real RH reading  
....................  rh = (float) humid;  
133C:  MOVFF  61,73
1340:  MOVFF  60,72
1344:  CALL   069A
1348:  MOVFF  03,65
134C:  MOVFF  02,64
1350:  MOVFF  01,63
1354:  MOVFF  00,62
....................  
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0;  
1358:  MOVFF  65,7D
135C:  MOVFF  64,7C
1360:  MOVFF  63,7B
1364:  MOVFF  62,7A
1368:  MOVLW  54
136A:  MOVWF  x81
136C:  MOVLW  E3
136E:  MOVWF  x80
1370:  MOVLW  25
1372:  MOVWF  x7F
1374:  MOVLW  7A
1376:  MOVWF  x7E
1378:  CALL   06F8
137C:  MOVFF  03,69
1380:  MOVFF  02,68
1384:  MOVFF  01,67
1388:  MOVFF  00,66
138C:  MOVFF  65,7D
1390:  MOVFF  64,7C
1394:  MOVFF  63,7B
1398:  MOVFF  62,7A
139C:  MOVFF  65,81
13A0:  MOVFF  64,80
13A4:  MOVFF  63,7F
13A8:  MOVFF  62,7E
13AC:  CALL   06F8
13B0:  MOVFF  03,6D
13B4:  MOVFF  02,6C
13B8:  MOVFF  01,6B
13BC:  MOVFF  00,6A
13C0:  MOVFF  03,7D
13C4:  MOVFF  02,7C
13C8:  MOVFF  01,7B
13CC:  MOVFF  00,7A
13D0:  MOVLW  A2
13D2:  MOVWF  x81
13D4:  MOVLW  E7
13D6:  MOVWF  x80
13D8:  MOVLW  3B
13DA:  MOVWF  x7F
13DC:  MOVLW  6C
13DE:  MOVWF  x7E
13E0:  CALL   06F8
13E4:  BSF    FD8.1
13E6:  MOVFF  69,79
13EA:  MOVFF  68,78
13EE:  MOVFF  67,77
13F2:  MOVFF  66,76
13F6:  MOVFF  03,7D
13FA:  MOVFF  02,7C
13FE:  MOVFF  01,7B
1402:  MOVFF  00,7A
1406:  CALL   07EA
140A:  MOVFF  03,69
140E:  MOVFF  02,68
1412:  MOVFF  01,67
1416:  MOVFF  00,66
141A:  BSF    FD8.1
141C:  MOVFF  03,79
1420:  MOVFF  02,78
1424:  MOVFF  01,77
1428:  MOVFF  00,76
142C:  CLRF   x7D
142E:  CLRF   x7C
1430:  CLRF   x7B
1432:  MOVLW  81
1434:  MOVWF  x7A
1436:  CALL   07EA
143A:  MOVFF  03,55
143E:  MOVFF  02,54
1442:  MOVFF  01,53
1446:  MOVFF  00,52
....................  
....................  //calculate True RH reading  
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin;  
144A:  BSF    FD8.1
144C:  MOVFF  49,79
1450:  MOVFF  48,78
1454:  MOVFF  47,77
1458:  MOVFF  46,76
145C:  CLRF   x7D
145E:  CLRF   x7C
1460:  MOVLW  48
1462:  MOVWF  x7B
1464:  MOVLW  83
1466:  MOVWF  x7A
1468:  CALL   07EA
146C:  MOVFF  03,69
1470:  MOVFF  02,68
1474:  MOVFF  01,67
1478:  MOVFF  00,66
147C:  MOVLW  AC
147E:  MOVWF  x7D
1480:  MOVLW  C5
1482:  MOVWF  x7C
1484:  MOVLW  27
1486:  MOVWF  x7B
1488:  MOVLW  71
148A:  MOVWF  x7A
148C:  MOVFF  65,81
1490:  MOVFF  64,80
1494:  MOVFF  63,7F
1498:  MOVFF  62,7E
149C:  CALL   06F8
14A0:  BCF    FD8.1
14A2:  MOVLW  0A
14A4:  MOVWF  x79
14A6:  MOVLW  D7
14A8:  MOVWF  x78
14AA:  MOVLW  23
14AC:  MOVWF  x77
14AE:  MOVLW  78
14B0:  MOVWF  x76
14B2:  MOVFF  03,7D
14B6:  MOVFF  02,7C
14BA:  MOVFF  01,7B
14BE:  MOVFF  00,7A
14C2:  CALL   07EA
14C6:  MOVFF  69,7D
14CA:  MOVFF  68,7C
14CE:  MOVFF  67,7B
14D2:  MOVFF  66,7A
14D6:  MOVFF  03,81
14DA:  MOVFF  02,80
14DE:  MOVFF  01,7F
14E2:  MOVFF  00,7E
14E6:  CALL   06F8
14EA:  MOVFF  03,69
14EE:  MOVFF  02,68
14F2:  MOVFF  01,67
14F6:  MOVFF  00,66
14FA:  BCF    FD8.1
14FC:  MOVFF  03,79
1500:  MOVFF  02,78
1504:  MOVFF  01,77
1508:  MOVFF  00,76
150C:  MOVFF  55,7D
1510:  MOVFF  54,7C
1514:  MOVFF  53,7B
1518:  MOVFF  52,7A
151C:  CALL   07EA
1520:  MOVFF  03,4D
1524:  MOVFF  02,4C
1528:  MOVFF  01,4B
152C:  MOVFF  00,4A
.................... }  
....................  
....................  
.................... //***** Function to measure & calculate SHT75 temp & RH *****  
....................  
.................... void sht_rd (float & temp, float & truehumid)  
.................... {  
....................  int16 restemp, reshumid;  
....................  float realhumid;  
....................  restemp = 0; truehumid = 0;  
*
1286:  CLRF   4F
1288:  CLRF   4E
128A:  CLRF   4D
128C:  CLRF   4C
128E:  CLRF   4B
1290:  CLRF   4A
....................  
....................  restemp = measuretemp();    //measure temp  
1292:  CALL   0672
1296:  MOVFF  02,4F
129A:  MOVFF  01,4E
....................  reshumid = measurehumid();  //measure RH  
129E:  CALL   06D0
12A2:  MOVFF  02,51
12A6:  MOVFF  01,50
.................... calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH  
12AA:  MOVFF  4F,5F
12AE:  MOVFF  4E,5E
12B2:  MOVFF  51,61
12B6:  MOVFF  50,60
.................... }  
....................  
....................  
.................... //***** Function to initialise SHT75 on power-up *****  
....................  
.................... void sht_init (void)  
.................... {  
....................  comreset();    //reset SHT75  
*
0518:  BRA    04D4
....................  delay_ms(20);  //delay for power-up  
051A:  MOVLW  14
051C:  MOVWF  4F
051E:  RCALL  0466
0520:  GOTO   122C (RETURN)
.................... } 
....................  
.................... //#include <MAX31855.c> 
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <LCDdriver.c> 
.................... int16 ms; 
....................  
.................... #int_timer2 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
0096:  INCF   1C,F
0098:  BTFSC  FD8.2
009A:  INCF   1D,F
009C:  BCF    F9E.1
009E:  GOTO   0054
.................... } 
....................  
.................... void main() { 
*
1158:  CLRF   FF8
115A:  BCF    FD0.7
115C:  BSF    07.7
115E:  BSF    FB8.3
1160:  MOVLW  81
1162:  MOVWF  FAF
1164:  MOVLW  00
1166:  MOVWF  FB0
1168:  MOVLW  A6
116A:  MOVWF  FAC
116C:  MOVLW  90
116E:  MOVWF  FAB
1170:  MOVF   FC1,W
1172:  ANDLW  C0
1174:  IORLW  0F
1176:  MOVWF  FC1
1178:  CLRF   16
117A:  CLRF   17
117C:  CLRF   37
117E:  CLRF   36
1180:  CLRF   35
1182:  MOVLW  1B
1184:  MOVWF  34
1186:  BCF    38.0
1188:  BSF    38.1
118A:  MOVLW  08
118C:  MOVWF  39
118E:  MOVLW  03
1190:  MOVWF  3A
1192:  CLRF   3B
....................    //setup_spi(SPI_MASTER | SPI_MODE_1 | SPI_CLK_DIV_64, );  
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................  
....................    int out_data_sht[8] ; // for sht 7x 
....................    int32 tx_idsht = 27; // id = 0x27 for sht7x 
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................  
....................    int f = 0; 
....................     
....................    for (f=0;f<8;f++) { 
1194:  CLRF   3B
1196:  MOVF   3B,W
1198:  SUBLW  07
119A:  BNC   11B2
....................      
....................       out_data_sht[f]=0x22; 
119C:  CLRF   03
119E:  MOVF   3B,W
11A0:  ADDLW  2C
11A2:  MOVWF  FE9
11A4:  MOVLW  00
11A6:  ADDWFC 03,W
11A8:  MOVWF  FEA
11AA:  MOVLW  22
11AC:  MOVWF  FEF
11AE:  INCF   3B,F
11B0:  BRA    1196
....................    } 
....................  
....................  //////////////////// 
.................... union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv  tempp_sht, hump_sht;  // p is alias pointer 
....................    int8 low, high; 
....................    setup_timer_2(T2_DIV_BY_16, 24, 1);   // 
11B2:  MOVLW  00
11B4:  IORLW  06
11B6:  MOVWF  FCA
11B8:  MOVLW  18
11BA:  MOVWF  FCB
....................    enable_interrupts(INT_TIMER1);   //enable timer2 interrupt 
11BC:  BSF    F9D.0
....................    set_tris_c(0x00); 
11BE:  MOVLW  00
11C0:  MOVWF  F94
....................    output_low(PIN_C2); 
11C2:  BCF    F94.2
11C4:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
11C6:  BCF    F94.2
11C8:  BCF    F8B.2
11CA:  MOVLW  0C
11CC:  MOVWF  FBD
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
11CE:  MOVLW  C0
11D0:  IORWF  FF2,F
....................    setup_adc(ADC_CLOCK_INTERNAL); //ADC_CLOCK_DIV_8 
11D2:  MOVF   FC0,W
11D4:  ANDLW  C0
11D6:  IORLW  07
11D8:  MOVWF  FC0
11DA:  BCF    FC0.7
11DC:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN1); //ALL_ANALOG 
11DE:  MOVF   FC1,W
11E0:  ANDLW  C0
11E2:  IORLW  0D
11E4:  MOVWF  FC1
....................     
.................... out_data_sht[0] = tempp_sht.b[0]; 
11E6:  MOVFF  3C,2C
.................... out_data_sht[1] = tempp_sht.b[1]; 
11EA:  MOVFF  3D,2D
.................... out_data_sht[2] = tempp_sht.b[2]; 
11EE:  MOVFF  3E,2E
.................... out_data_sht[3] = tempp_sht.b[3]; 
11F2:  MOVFF  3F,2F
....................  
.................... out_data_sht[4] = hump_sht.b[0]; 
11F6:  MOVFF  40,30
.................... out_data_sht[5] = hump_sht.b[1]; 
11FA:  MOVFF  41,31
.................... out_data_sht[6] = hump_sht.b[2]; 
11FE:  MOVFF  42,32
.................... out_data_sht[7] = hump_sht.b[3]; 
1202:  MOVFF  43,33
....................  
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",val2.f,\  
.................... //    val2.b[0],val2.b[1],val2.b[2],val2.b[3]);  
.................... //    //The new float value, and the bytes that make it.  
....................  
....................  ////////////////////  
.................... // float temp,press,hu; 
....................  float truetempsht, truehumidsht; 
....................    printf("\r\n\r\nCCS CAN TRANSFER BME280 DATA\r\n"); 
1206:  MOVLW  A2
1208:  MOVWF  FF6
120A:  MOVLW  00
120C:  MOVWF  FF7
120E:  CALL   01E6
....................  
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
1212:  MOVLW  78
1214:  IORLW  05
1216:  MOVWF  FCA
1218:  MOVLW  4F
121A:  MOVWF  FCB
....................  
....................    can_init(); 
121C:  GOTO   038A
....................    //init_BME280(); 
....................    //BME280Begin(); 
....................    delay_ms(200); 
1220:  MOVLW  C8
1222:  MOVWF  4F
1224:  CALL   0466
....................    sht_init() ;// init sht75 
1228:  GOTO   0518
....................    delay_ms(10); 
122C:  MOVLW  0A
122E:  MOVWF  4F
1230:  CALL   0466
....................     
....................   // can_set_mode(CAN_OP_LOOPBACK); 
....................    
....................    enable_interrupts(INT_TIMER2);   //enable timer2 interrupt 
1234:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
1236:  MOVLW  C0
1238:  IORWF  FF2,F
....................  
....................    printf("\r\nRunning..."); 
123A:  MOVLW  C6
123C:  MOVWF  FF6
123E:  MOVLW  00
1240:  MOVWF  FF7
1242:  CALL   01E6
....................     
....................     
....................    while(TRUE) 
....................    {    
....................          
....................         truetempsht = measuretemp(); 
1246:  CALL   0672
124A:  MOVFF  02,73
124E:  MOVFF  01,72
1252:  CALL   069A
1256:  MOVFF  03,49
125A:  MOVFF  02,48
125E:  MOVFF  01,47
1262:  MOVFF  00,46
....................         truehumidsht = measurehumid(); 
1266:  CALL   06D0
126A:  MOVFF  02,73
126E:  MOVFF  01,72
1272:  CALL   069A
1276:  MOVFF  03,4D
127A:  MOVFF  02,4C
127E:  MOVFF  01,4B
1282:  MOVFF  00,4A
....................         sht_rd(truetempsht,truehumidsht); 
....................         delay_ms(10); 
*
1530:  MOVLW  0A
1532:  MOVWF  4F
1534:  CALL   0466
....................         printf("\r\nTemperature SHT71 = %f3",truetempsht); 
1538:  MOVLW  D4
153A:  MOVWF  FF6
153C:  MOVLW  00
153E:  MOVWF  FF7
1540:  MOVLW  16
1542:  MOVWF  52
1544:  CALL   0A54
1548:  MOVLW  89
154A:  MOVWF  FE9
154C:  MOVFF  49,51
1550:  MOVFF  48,50
1554:  MOVFF  47,4F
1558:  MOVFF  46,4E
155C:  MOVLW  02
155E:  MOVWF  52
1560:  CALL   0B42
1564:  MOVLW  33
1566:  BTFSS  F9E.4
1568:  BRA    1566
156A:  MOVWF  FAD
....................         printf("\r\nHumidity SHT71 = %f3",truehumidsht); 
156C:  MOVLW  EE
156E:  MOVWF  FF6
1570:  MOVLW  00
1572:  MOVWF  FF7
1574:  MOVLW  13
1576:  MOVWF  52
1578:  CALL   0A54
157C:  MOVLW  89
157E:  MOVWF  FE9
1580:  MOVFF  4D,51
1584:  MOVFF  4C,50
1588:  MOVFF  4B,4F
158C:  MOVFF  4A,4E
1590:  MOVLW  02
1592:  MOVWF  52
1594:  CALL   0B42
1598:  MOVLW  33
159A:  BTFSS  F9E.4
159C:  BRA    159A
159E:  MOVWF  FAD
....................          
....................          tempp_sht.f = truetempsht;         
15A0:  MOVFF  49,3F
15A4:  MOVFF  48,3E
15A8:  MOVFF  47,3D
15AC:  MOVFF  46,3C
....................          out_data_sht[0] = tempp_sht.b[0]; 
15B0:  MOVFF  3C,2C
....................          out_data_sht[1] = tempp_sht.b[1]; 
15B4:  MOVFF  3D,2D
....................          out_data_sht[2] = tempp_sht.b[2]; 
15B8:  MOVFF  3E,2E
....................          out_data_sht[3] = tempp_sht.b[3]; 
15BC:  MOVFF  3F,2F
....................           
....................          hump_sht.f =truehumidsht; 
15C0:  MOVFF  4D,43
15C4:  MOVFF  4C,42
15C8:  MOVFF  4B,41
15CC:  MOVFF  4A,40
....................          out_data_sht[4] = hump_sht.b[0]; 
15D0:  MOVFF  40,30
....................          out_data_sht[5] = hump_sht.b[1]; 
15D4:  MOVFF  41,31
....................          out_data_sht[6] = hump_sht.b[2]; 
15D8:  MOVFF  42,32
....................          out_data_sht[7] = hump_sht.b[3]; 
15DC:  MOVFF  43,33
....................           delay_ms(10); 
15E0:  MOVLW  0A
15E2:  MOVWF  4F
15E4:  CALL   0466
....................    
....................    
....................        set_adc_channel(0); // EasyPIC Board: Read ADC 2 for PWM fan 
15E8:  MOVLW  00
15EA:  MOVWF  01
15EC:  MOVF   FC2,W
15EE:  ANDLW  C3
15F0:  IORWF  01,W
15F2:  MOVWF  FC2
....................        delay_ms(20); 
15F4:  MOVLW  14
15F6:  MOVWF  4F
15F8:  CALL   0466
....................        low= read_adc()/3; // 36 
15FC:  BSF    FC2.1
15FE:  BTFSC  FC2.1
1600:  BRA    15FE
1602:  MOVFF  FC4,54
1606:  MOVLW  03
1608:  MOVWF  55
160A:  CALL   0CC2
160E:  MOVFF  01,44
....................        if(low <70) 
1612:  MOVF   44,W
1614:  SUBLW  45
1616:  BNC   161C
....................        low =70; // low is from 70-85 
1618:  MOVLW  46
161A:  MOVWF  44
....................        if(low>85) 
161C:  MOVF   44,W
161E:  SUBLW  55
1620:  BC    1626
....................        low =85; 
1622:  MOVLW  55
1624:  MOVWF  44
....................        printf("\r\n\low=%u",low); 
1626:  MOVLW  06
1628:  MOVWF  FF6
162A:  MOVLW  01
162C:  MOVWF  FF7
162E:  MOVLW  06
1630:  MOVWF  52
1632:  CALL   0A54
1636:  MOVFF  44,52
163A:  MOVLW  1B
163C:  MOVWF  53
163E:  CALL   0CEA
....................        set_adc_channel(1); // EasyPIC Board: Read ADC 2 for PWM fan 
1642:  MOVLW  04
1644:  MOVWF  01
1646:  MOVF   FC2,W
1648:  ANDLW  C3
164A:  IORWF  01,W
164C:  MOVWF  FC2
....................        delay_ms(20); 
164E:  MOVLW  14
1650:  MOVWF  4F
1652:  CALL   0466
....................        high= read_adc()/3; // from 75-90 % 
1656:  BSF    FC2.1
1658:  BTFSC  FC2.1
165A:  BRA    1658
165C:  MOVFF  FC4,54
1660:  MOVLW  03
1662:  MOVWF  55
1664:  CALL   0CC2
1668:  MOVFF  01,45
....................        high = high + 5; 
166C:  MOVLW  05
166E:  ADDWF  45,F
....................        if(high<75) 
1670:  MOVF   45,W
1672:  SUBLW  4A
1674:  BNC   167A
....................         
....................        high = 75; 
1676:  MOVLW  4B
1678:  MOVWF  45
....................        if(high>85) 
167A:  MOVF   45,W
167C:  SUBLW  55
167E:  BC    1684
....................        high = 85; 
1680:  MOVLW  55
1682:  MOVWF  45
....................        //high = high + 35; 
....................        //if((high > 60)||(high<35)) 
....................        //high = 60; 
....................        printf("\r\n\high=%u",high); 
1684:  MOVLW  10
1686:  MOVWF  FF6
1688:  MOVLW  01
168A:  MOVWF  FF7
168C:  MOVLW  07
168E:  MOVWF  52
1690:  CALL   0A54
1694:  MOVFF  45,52
1698:  MOVLW  1B
169A:  MOVWF  53
169C:  CALL   0CEA
....................        set_pwm1_duty(high);  
16A0:  MOVFF  45,FBE
....................        if(truehumidsht<low)   
16A4:  CLRF   x73
16A6:  MOVFF  44,72
16AA:  CALL   069A
16AE:  MOVFF  4D,51
16B2:  MOVFF  4C,50
16B6:  MOVFF  4B,4F
16BA:  MOVFF  4A,4E
16BE:  MOVFF  03,55
16C2:  MOVFF  02,54
16C6:  MOVFF  01,53
16CA:  MOVFF  00,52
16CE:  CALL   0D56
16D2:  BNC   16D6
....................        { 
....................        set_pwm1_duty(255);  
16D4:  SETF   FBE
....................        } 
....................        if(truehumidsht>high) 
16D6:  CLRF   x73
16D8:  MOVFF  45,72
16DC:  CALL   069A
16E0:  MOVFF  03,51
16E4:  MOVFF  02,50
16E8:  MOVFF  01,4F
16EC:  MOVFF  00,4E
16F0:  MOVFF  4D,55
16F4:  MOVFF  4C,54
16F8:  MOVFF  4B,53
16FC:  MOVFF  4A,52
1700:  CALL   0D56
1704:  BNC   1708
....................        { 
....................        set_pwm1_duty(0);  
1706:  CLRF   FBE
....................        } 
....................        if((truehumidsht>low)&&(truehumidsht<high)) 
1708:  CLRF   x73
170A:  MOVFF  44,72
170E:  CALL   069A
1712:  MOVFF  03,51
1716:  MOVFF  02,50
171A:  MOVFF  01,4F
171E:  MOVFF  00,4E
1722:  MOVFF  4D,55
1726:  MOVFF  4C,54
172A:  MOVFF  4B,53
172E:  MOVFF  4A,52
1732:  CALL   0D56
1736:  BNC   176C
1738:  CLRF   x73
173A:  MOVFF  45,72
173E:  CALL   069A
1742:  MOVFF  4D,51
1746:  MOVFF  4C,50
174A:  MOVFF  4B,4F
174E:  MOVFF  4A,4E
1752:  MOVFF  03,55
1756:  MOVFF  02,54
175A:  MOVFF  01,53
175E:  MOVFF  00,52
1762:  CALL   0D56
1766:  BNC   176C
....................        { 
....................        set_pwm1_duty(18); 
1768:  MOVLW  12
176A:  MOVWF  FBE
....................        } 
....................         
....................       if ( can_kbhit() )   //if data is waiting in buffer... 
176C:  BTFSC  F60.7
176E:  BRA    1778
1770:  MOVLB  F
1772:  BTFSS  x50.7
1774:  BRA    1A0C
1776:  MOVLB  0
....................       { 
....................          if(can_getd(rx_id, &in_data[0], rx_len, rxstat)) { //...then get data from buffer 
1778:  CLRF   4F
177A:  MOVLW  23
177C:  MOVWF  4E
*
187C:  MOVF   01,F
187E:  BTFSC  FD8.2
1880:  BRA    19FC
....................             printf("\r\nGOT: BUFF=%U ID=%LU LEN=%U OVF=%U ", rxstat.buffer, rx_id, rx_len, rxstat.err_ovfl); 
1882:  MOVLW  00
1884:  BTFSC  1E.4
1886:  MOVLW  01
1888:  MOVWF  4E
188A:  MOVLW  00
188C:  BTFSC  1E.0
188E:  MOVLW  01
1890:  MOVWF  4F
1892:  MOVLW  1A
1894:  MOVWF  FF6
1896:  MOVLW  01
1898:  MOVWF  FF7
189A:  MOVLW  0C
189C:  MOVWF  52
189E:  MOVLB  0
18A0:  CALL   0A54
18A4:  MOVFF  4E,52
18A8:  MOVLW  1B
18AA:  MOVWF  53
18AC:  CALL   0CEA
18B0:  MOVLW  28
18B2:  MOVWF  FF6
18B4:  MOVLW  01
18B6:  MOVWF  FF7
18B8:  MOVLW  04
18BA:  MOVWF  52
18BC:  CALL   0A54
18C0:  MOVLW  41
18C2:  MOVWF  FE9
18C4:  MOVFF  22,53
18C8:  MOVFF  21,52
18CC:  MOVFF  20,51
18D0:  MOVFF  1F,50
18D4:  CALL   0FAE
18D8:  MOVLW  2F
18DA:  MOVWF  FF6
18DC:  MOVLW  01
18DE:  MOVWF  FF7
18E0:  MOVLW  05
18E2:  MOVWF  52
18E4:  CALL   0A54
18E8:  MOVFF  2B,52
18EC:  MOVLW  1B
18EE:  MOVWF  53
18F0:  CALL   0CEA
18F4:  MOVLW  36
18F6:  MOVWF  FF6
18F8:  MOVLW  01
18FA:  MOVWF  FF7
18FC:  MOVLW  05
18FE:  MOVWF  52
1900:  CALL   0A54
1904:  MOVFF  4F,52
1908:  MOVLW  1B
190A:  MOVWF  53
190C:  CALL   0CEA
1910:  MOVLW  20
1912:  BTFSS  F9E.4
1914:  BRA    1912
1916:  MOVWF  FAD
....................             printf("FILT=%U RTR=%U EXT=%U INV=%U", rxstat.filthit, rxstat.rtr, rxstat.ext, rxstat.inv); 
1918:  MOVFF  1E,00
191C:  RRCF   1E,W
191E:  ANDLW  07
1920:  MOVWF  4E
1922:  MOVLW  00
1924:  BTFSC  1E.5
1926:  MOVLW  01
1928:  MOVWF  4F
192A:  MOVLW  00
192C:  BTFSC  1E.6
192E:  MOVLW  01
1930:  MOVWF  50
1932:  MOVLW  00
1934:  BTFSC  1E.7
1936:  MOVLW  01
1938:  MOVWF  51
193A:  MOVLW  40
193C:  MOVWF  FF6
193E:  MOVLW  01
1940:  MOVWF  FF7
1942:  MOVLW  05
1944:  MOVWF  52
1946:  CALL   0A54
194A:  MOVFF  4E,52
194E:  MOVLW  1B
1950:  MOVWF  53
1952:  CALL   0CEA
1956:  MOVLW  47
1958:  MOVWF  FF6
195A:  MOVLW  01
195C:  MOVWF  FF7
195E:  MOVLW  05
1960:  MOVWF  52
1962:  CALL   0A54
1966:  MOVFF  4F,52
196A:  MOVLW  1B
196C:  MOVWF  53
196E:  CALL   0CEA
1972:  MOVLW  4E
1974:  MOVWF  FF6
1976:  MOVLW  01
1978:  MOVWF  FF7
197A:  MOVLW  05
197C:  MOVWF  52
197E:  CALL   0A54
1982:  MOVFF  50,52
1986:  MOVLW  1B
1988:  MOVWF  53
198A:  CALL   0CEA
198E:  MOVLW  55
1990:  MOVWF  FF6
1992:  MOVLW  01
1994:  MOVWF  FF7
1996:  MOVLW  05
1998:  MOVWF  52
199A:  CALL   0A54
199E:  MOVFF  51,52
19A2:  MOVLW  1B
19A4:  MOVWF  53
19A6:  CALL   0CEA
....................             printf("\r\n    DATA = "); 
19AA:  MOVLW  5E
19AC:  MOVWF  FF6
19AE:  MOVLW  01
19B0:  MOVWF  FF7
19B2:  CALL   01E6
....................             for (f=0;f<rx_len;f++) { 
19B6:  CLRF   3B
19B8:  MOVF   2B,W
19BA:  SUBWF  3B,W
19BC:  BC    19E8
....................                printf("%X ",in_data[f]); 
19BE:  CLRF   03
19C0:  MOVF   3B,W
19C2:  ADDLW  23
19C4:  MOVWF  FE9
19C6:  MOVLW  00
19C8:  ADDWFC 03,W
19CA:  MOVWF  FEA
19CC:  MOVFF  FEF,4E
19D0:  MOVFF  4E,4F
19D4:  MOVLW  37
19D6:  MOVWF  50
19D8:  CALL   1054
19DC:  MOVLW  20
19DE:  BTFSS  F9E.4
19E0:  BRA    19DE
19E2:  MOVWF  FAD
19E4:  INCF   3B,F
19E6:  BRA    19B8
....................             } 
....................             printf("\r\n"); 
19E8:  MOVLW  0D
19EA:  BTFSS  F9E.4
19EC:  BRA    19EA
19EE:  MOVWF  FAD
19F0:  MOVLW  0A
19F2:  BTFSS  F9E.4
19F4:  BRA    19F2
19F6:  MOVWF  FAD
....................          } 
19F8:  BRA    1A0A
19FA:  MOVLB  F
....................          else { 
....................             printf("\r\nFAIL on GETD\r\n"); 
19FC:  MOVLW  6C
19FE:  MOVWF  FF6
1A00:  MOVLW  01
1A02:  MOVWF  FF7
1A04:  MOVLB  0
1A06:  CALL   01E6
1A0A:  MOVLB  F
....................          } 
....................  
....................       } 
....................       //every two seconds, send new data if transmit buffer is empty 
....................       if ( can_tbe() && (ms > 2000)) 
1A0C:  BTFSS  x40.3
1A0E:  BRA    1A18
1A10:  BTFSS  x30.3
1A12:  BRA    1A18
1A14:  BTFSC  x20.3
1A16:  BRA    1C1C
1A18:  MOVF   1D,W
1A1A:  SUBLW  06
1A1C:  BTFSC  FD8.0
1A1E:  BRA    1C1C
1A20:  XORLW  FF
1A22:  BNZ   1A2C
1A24:  MOVF   1C,W
1A26:  SUBLW  D0
1A28:  BTFSC  FD8.0
1A2A:  BRA    1C1C
....................       { 
....................          ms=0;     
1A2C:  CLRF   1D
1A2E:  CLRF   1C
....................          f=can_putd(tx_idsht, out_data_sht, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
1A30:  MOVLW  00
1A32:  BTFSC  38.1
1A34:  MOVLW  01
1A36:  MOVWF  4E
1A38:  MOVLW  00
1A3A:  BTFSC  38.0
1A3C:  MOVLW  01
1A3E:  MOVWF  4F
1A40:  MOVFF  37,53
1A44:  MOVFF  36,52
1A48:  MOVFF  35,51
1A4C:  MOVFF  34,50
1A50:  CLRF   55
1A52:  MOVLW  2C
1A54:  MOVWF  54
1A56:  MOVFF  39,56
1A5A:  MOVFF  3A,57
1A5E:  MOVFF  4E,58
1A62:  MOVFF  4F,59
1A66:  MOVLB  0
1A68:  GOTO   1096
1A6C:  MOVFF  01,3B
....................          if(f != 0xFF) 
1A70:  INCFSZ 3B,W
1A72:  BRA    1A76
1A74:  BRA    1C0E
....................          {     
....................                printf("\r\nPUT %U: ID=%LU LEN=%U ", f, tx_idsht, tx_len);  //i return 1 if transmit success 
1A76:  MOVLW  7E
1A78:  MOVWF  FF6
1A7A:  MOVLW  01
1A7C:  MOVWF  FF7
1A7E:  MOVLW  06
1A80:  MOVWF  52
1A82:  CALL   0A54
1A86:  MOVFF  3B,52
1A8A:  MOVLW  1B
1A8C:  MOVWF  53
1A8E:  CALL   0CEA
1A92:  MOVLW  86
1A94:  MOVWF  FF6
1A96:  MOVLW  01
1A98:  MOVWF  FF7
1A9A:  MOVLW  05
1A9C:  MOVWF  52
1A9E:  CALL   0A54
1AA2:  MOVLW  41
1AA4:  MOVWF  FE9
1AA6:  MOVFF  37,53
1AAA:  MOVFF  36,52
1AAE:  MOVFF  35,51
1AB2:  MOVFF  34,50
1AB6:  CALL   0FAE
1ABA:  MOVLW  8E
1ABC:  MOVWF  FF6
1ABE:  MOVLW  01
1AC0:  MOVWF  FF7
1AC2:  MOVLW  05
1AC4:  MOVWF  52
1AC6:  CALL   0A54
1ACA:  MOVFF  39,52
1ACE:  MOVLW  1B
1AD0:  MOVWF  53
1AD2:  CALL   0CEA
1AD6:  MOVLW  20
1AD8:  BTFSS  F9E.4
1ADA:  BRA    1AD8
1ADC:  MOVWF  FAD
....................                printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
1ADE:  MOVLW  00
1AE0:  BTFSC  38.1
1AE2:  MOVLW  01
1AE4:  MOVWF  4E
1AE6:  MOVLW  00
1AE8:  BTFSC  38.0
1AEA:  MOVLW  01
1AEC:  MOVWF  4F
1AEE:  MOVLW  98
1AF0:  MOVWF  FF6
1AF2:  MOVLW  01
1AF4:  MOVWF  FF7
1AF6:  MOVLW  04
1AF8:  MOVWF  52
1AFA:  CALL   0A54
1AFE:  MOVFF  3A,52
1B02:  MOVLW  1B
1B04:  MOVWF  53
1B06:  CALL   0CEA
1B0A:  MOVLW  9E
1B0C:  MOVWF  FF6
1B0E:  MOVLW  01
1B10:  MOVWF  FF7
1B12:  MOVLW  05
1B14:  MOVWF  52
1B16:  CALL   0A54
1B1A:  MOVFF  4E,52
1B1E:  MOVLW  1B
1B20:  MOVWF  53
1B22:  CALL   0CEA
1B26:  MOVLW  A5
1B28:  MOVWF  FF6
1B2A:  MOVLW  01
1B2C:  MOVWF  FF7
1B2E:  MOVLW  05
1B30:  MOVWF  52
1B32:  CALL   0A54
1B36:  MOVFF  4F,52
1B3A:  MOVLW  1B
1B3C:  MOVWF  53
1B3E:  CALL   0CEA
1B42:  MOVLW  AC
1B44:  MOVWF  FF6
1B46:  MOVLW  01
1B48:  MOVWF  FF7
1B4A:  MOVLW  0C
1B4C:  MOVWF  52
1B4E:  CALL   0A54
....................                for (f=0;f<tx_len;f++) { 
1B52:  CLRF   3B
1B54:  MOVF   39,W
1B56:  SUBWF  3B,W
1B58:  BC    1B94
....................                printf("\r\n%X ",out_data_sht[f]); 
1B5A:  CLRF   03
1B5C:  MOVF   3B,W
1B5E:  ADDLW  2C
1B60:  MOVWF  FE9
1B62:  MOVLW  00
1B64:  ADDWFC 03,W
1B66:  MOVWF  FEA
1B68:  MOVFF  FEF,4E
1B6C:  MOVLW  0D
1B6E:  BTFSS  F9E.4
1B70:  BRA    1B6E
1B72:  MOVWF  FAD
1B74:  MOVLW  0A
1B76:  BTFSS  F9E.4
1B78:  BRA    1B76
1B7A:  MOVWF  FAD
1B7C:  MOVFF  4E,4F
1B80:  MOVLW  37
1B82:  MOVWF  50
1B84:  CALL   1054
1B88:  MOVLW  20
1B8A:  BTFSS  F9E.4
1B8C:  BRA    1B8A
1B8E:  MOVWF  FAD
1B90:  INCF   3B,F
1B92:  BRA    1B54
....................             } 
....................              printf("\r\n"); 
1B94:  MOVLW  0D
1B96:  BTFSS  F9E.4
1B98:  BRA    1B96
1B9A:  MOVWF  FAD
1B9C:  MOVLW  0A
1B9E:  BTFSS  F9E.4
1BA0:  BRA    1B9E
1BA2:  MOVWF  FAD
....................              printf("\r\nPUT %U: ID=%LU LEN=%U ", f, tx_idsht, tx_len); 
1BA4:  MOVLW  BA
1BA6:  MOVWF  FF6
1BA8:  MOVLW  01
1BAA:  MOVWF  FF7
1BAC:  MOVLW  06
1BAE:  MOVWF  52
1BB0:  CALL   0A54
1BB4:  MOVFF  3B,52
1BB8:  MOVLW  1B
1BBA:  MOVWF  53
1BBC:  CALL   0CEA
1BC0:  MOVLW  C2
1BC2:  MOVWF  FF6
1BC4:  MOVLW  01
1BC6:  MOVWF  FF7
1BC8:  MOVLW  05
1BCA:  MOVWF  52
1BCC:  CALL   0A54
1BD0:  MOVLW  41
1BD2:  MOVWF  FE9
1BD4:  MOVFF  37,53
1BD8:  MOVFF  36,52
1BDC:  MOVFF  35,51
1BE0:  MOVFF  34,50
1BE4:  CALL   0FAE
1BE8:  MOVLW  CA
1BEA:  MOVWF  FF6
1BEC:  MOVLW  01
1BEE:  MOVWF  FF7
1BF0:  MOVLW  05
1BF2:  MOVWF  52
1BF4:  CALL   0A54
1BF8:  MOVFF  39,52
1BFC:  MOVLW  1B
1BFE:  MOVWF  53
1C00:  CALL   0CEA
1C04:  MOVLW  20
1C06:  BTFSS  F9E.4
1C08:  BRA    1C06
1C0A:  MOVWF  FAD
....................          } 
1C0C:  BRA    1C1A
....................           else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
1C0E:  MOVLW  D4
1C10:  MOVWF  FF6
1C12:  MOVLW  01
1C14:  MOVWF  FF7
1C16:  CALL   01E6
1C1A:  MOVLB  F
....................          
....................          } 
....................       } 
....................     
....................        
....................      delay_ms(500);  
1C1C:  MOVLW  02
1C1E:  MOVWF  4E
1C20:  MOVLW  FA
1C22:  MOVWF  4F
1C24:  MOVLB  0
1C26:  CALL   0466
1C2A:  DECFSZ 4E,F
1C2C:  BRA    1C30
1C2E:  BRA    1C34
1C30:  MOVLB  F
1C32:  BRA    1C20
1C34:  GOTO   1246
....................    } 
.................... } 
1C38:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
